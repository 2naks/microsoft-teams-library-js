{"version":3,"sources":["webpack://microsoftTeams/webpack/universalModuleDefinition","webpack://microsoftTeams/webpack/bootstrap","webpack://microsoftTeams/./src/index.ts","webpack://microsoftTeams/./src/MicrosoftTeams.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__export","version","generateRegExpFromUrl","url","urlRegExpPart","urlParts","split","j","length","replace","validOriginRegExp","urls","urlRegExp","RegExp","generateRegExpFromUrls","handlers","frameContexts","settings","content","authentication","remove","task","menus","navBarMenuItemPressHandler","actionMenuItemPressHandler","viewConfigItemPressHandler","MenuItem","this","enabled","MenuListType","id","ensureInitialized","sendMessageRequest","parentWindow","setUpViews","viewConfig","handler","setNavBarMenu","items","showActionMenu","params","currentWindow","parentOrigin","childWindow","childOrigin","frameContext","hostClientType","themeChangeHandler","fullScreenChangeHandler","backButtonPressHandler","beforeUnloadHandler","changeSettingsHandler","initializeCalled","isFramelessWindow","parentMessageQueue","childMessageQueue","nextMessageId","callbacks","printCapabilityEnabled","print","registerOnThemeChangeHandler","registerFullScreenHandler","registerBackButtonHandler","navigateBack","messageId","success","Error","registerBeforeUnloadHandler","expectedFrameContexts","_i","arguments","found","processMessage","evt","data","messageSource","source","originalEvent","messageOrigin","origin","location","test","toLowerCase","updateRelationships","handleParentMessage","handleChildMessage","closed","flushMessageQueue","message","callback","apply","args","func","message_1","result","sendMessageResponse","Array","isArray","getTargetMessageQueue","targetWindow","getTargetOrigin","targetOrigin","targetMessageQueue","postMessage","shift","waitForMessageQueue","messageQueueMonitor","setInterval","clearInterval","actionName","request","createMessageRequest","nativeInterface","framelessPostMessage","JSON","stringify","push","response","createMessageResponse","theme","isFullScreen","readyToUnload","initialize","hostWindow","messageListener","parent","self","opener","addEventListener","onNativeMessage","context","clientType","_uninitialize","registerOnSaveHandler","registerOnRemoveHandler","removeEventListener","enablePrintCapability","document","event","ctrlKey","metaKey","keyCode","cancelBubble","preventDefault","stopImmediatePropagation","getContext","registerChangeSettingsHandler","navigateCrossDomain","getTabInstances","tabInstanceParameters","getUserJoinedTeams","teamInstanceParameters","getMruTabInstances","shareDeepLink","deepLinkParameters","subEntityId","subEntityLabel","subEntityWebUrl","openFilePreview","filePreviewParameters","entityId","title","description","type","objectUrl","downloadUrl","webPreviewUrl","webEditUrl","baseUrl","editFile","showNotification","showNotificationParameters","notificationType","executeDeepLink","deepLink","uploadCustomApp","manifestBlob","navigateToTab","tabInstance","saveHandler","removeHandler","saveEvent","SaveEventImpl","notifySuccess","removeEvent","RemoveEventImpl","setValidityState","validityState","getSettings","setSettings","instanceSettings","notified","ensureNotNotified","notifyFailure","reason","authParams","authWindowMonitor","closeAuthenticationWindow","stopAuthenticationWindowMonitor","close","openAuthenticationWindow","authenticateParameters","width","height","Math","min","outerWidth","outerHeight","link","createElement","href","left","screenLeft","screenX","top","screenTop","screenY","open","startAuthenticationWindowMonitor","handleFailure","savedChildOrigin","failureCallback","redirectIfWin32Outlook","callbackUrl","decodeURIComponent","host","search","indexOf","updateUrlParameter","assign","uri","hash","substr","successCallback","registerAuthenticationHandlers","authenticate","authenticateParams","undefined","getAuthToken","authTokenRequest","resources","getUser","userRequest","setTimeout","sendCustomMessage","tasks","startTask","taskInfo","submitHandler","updateTask","extra","__rest","keys","submitTask","appIds","getChatMembers"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,OAAA,oBAAAH,GACA,iBAAAC,QACAA,QAAA,eAAAD,IAEAD,EAAA,eAAAC,IARA,CASCK,OAAA,WACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAT,YAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA0DA,OArDAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAtB,GACA,oBAAAuB,eAAAC,aACAN,OAAAC,eAAAnB,EAAAuB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAnB,EAAA,cAAiDyB,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAhC,GACA,IAAAe,EAAAf,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,GAIAhC,IAAAiC,EAAA,+IClFAC,CAAAlC,EAAA,kYC+BA,IAAMmC,EAAU,QAmBhB,SAAAC,EAA+BC,GAG7B,IAFA,IAAIC,EAAgB,IACdC,EAAWF,EAAIG,MAAM,KAClBC,EAAI,EAAGA,EAAIF,EAASG,OAAQD,IACnCH,IAAkBG,EAAI,EAAI,MAAQ,IAAMF,EAASE,GAAGE,QAAQ,IAAK,WAGnE,OADAL,GAAiB,IAanB,IAAMM,EARN,SAAgCC,GAE9B,IADA,IAAIC,EAAY,GACP5C,EAAI,EAAGA,EAAI2C,EAAKH,OAAQxC,IAC/B4C,IAAoB,IAAN5C,EAAU,GAAK,KAAOkC,EAAsBS,EAAK3C,IAEjE,OAAO,IAAI6C,OAAOD,GAGME,EAnCxB,8BACA,6BACA,kCACA,8BACA,2BACA,mBACA,wBACA,0BACA,2BACA,8BACA,iCACA,6BACA,mCAyBIC,KAGAC,GACJC,SAAU,WACVC,QAAS,UACTC,eAAgB,iBAChBC,OAAQ,SACRC,KAAM,SA4BR,SAAiBC,GAwBf,IAiEIC,EAGAC,EAGAC,EAvEJC,EAAA,WAmCA,OAnCA,WA6BSC,KAAAC,SAAmB,GA7B5B,GAAaN,EAAAI,SAAQA,EA4DrB,SAAYG,GACVA,EAAA,oBACAA,EAAA,kBAFF,CAAYP,EAAAO,eAAAP,EAAAO,kBAMZd,EAA8B,oBA6C9B,SAAmCe,GAC5BP,GAA+BA,EAA2BO,KAC7DC,IACAC,EAAmBC,EAAc,6BAA8BH,MA7CnEf,EAA8B,oBA4E9B,SAAmCe,GAC5BN,GAA+BA,EAA2BM,KAC7DC,IACAC,EAAmBC,EAAc,6BAA8BH,MA5EnEf,EAAwB,cAiBxB,SAAmCe,GAC5BL,GAA+BA,EAA2BK,KAC7DC,IACAC,EAAmBC,EAAc,uBAAwBH,MAZ7CR,EAAAY,WAAhB,SACEC,EACAC,GAEAL,IACAN,EAA6BW,EAC7BJ,EAAmBC,EAAc,cAAeE,KAelCb,EAAAe,cAAhB,SACEC,EACAF,GAEAL,IAEAR,EAA6Ba,EAC7BJ,EAAmBC,EAAc,iBAAkBK,KA2BrChB,EAAAiB,eAAhB,SACEC,EACAJ,GAEAL,IAEAP,EAA6BY,EAC7BJ,EAAmBC,EAAc,kBAAmBO,KAtKxD,CAAiBhF,EAAA8D,QAAA9D,EAAA8D,WA0WjB,IAGImB,EACAR,EACAS,EAEAC,EACAC,EAIAC,EACAC,EAGAC,EAGAC,EAGAC,EAGAC,EAGAC,EA0dalC,EAtfbmC,GAAmB,EAEnBC,GAAoB,EAIpBC,KAGAC,KACAC,EAAgB,EAChBC,KAGAC,GAAkC,EA+HtC,SAAAC,IACE/F,OAAO+F,QAmBT,SAAAC,EACExB,GAEAL,IAEAgB,EAAqBX,EACrBA,GACEJ,EAAmBC,EAAc,mBAAoB,gBAkBzD,SAAA4B,EACEzB,GAEAL,IAEAiB,EAA0BZ,EAC1BA,GACEJ,EAAmBC,EAAc,mBAAoB,eAgBzD,SAAA6B,EAA0C1B,GACxCL,IAEAkB,EAAyBb,EACzBA,GACEJ,EAAmBC,EAAc,mBAAoB,eAazD,SAAA8B,IACEhC,IAEA,IAAMiC,EAAYhC,EAAmBC,EAAc,mBACnDwB,EAAUO,GAAa,SAACC,GACtB,IAAKA,EACH,MAAM,IAAIC,MACR,uEAWR,SAAAC,EACE/B,GAEAL,IAEAmB,EAAsBd,EACtBA,GACEJ,EAAmBC,EAAc,mBAAoB,iBA6sCzD,SAAAF,QAA2B,IAAAqC,KAAAC,EAAA,EAAAA,EAAAC,UAAA9D,OAAA6D,IAAAD,EAAAC,GAAAC,UAAAD,GACzB,IAAKjB,EACH,MAAM,IAAIc,MAAM,4CAGlB,GACErB,GACAuB,GACAA,EAAsB5D,OAAS,EAC/B,CAEA,IADA,IAAI+D,GAAQ,EACHvG,EAAI,EAAGA,EAAIoG,EAAsB5D,OAAQxC,IAChD,GAAIoG,EAAsBpG,KAAO6E,EAAc,CAC7C0B,GAAQ,EACR,MAIJ,IAAKA,EACH,MAAM,IAAIL,MACR,oCAAsCrB,EAAe,cAM7D,SAAA2B,EAAwBC,GAEtB,GAAKA,GAAQA,EAAIC,MAA4B,iBAAbD,EAAIC,KAApC,CAKA,IAAMC,EAAgBF,EAAIG,QAAUH,EAAII,cAAcD,OAChDE,EAAgBL,EAAIM,QAAUN,EAAII,cAAcE,OAEpDJ,IAAkBlC,GACjBqC,IAAkBrC,EAAcuC,SAASD,SACvCrE,EAAkBuE,KAAKH,EAAcI,iBAM1CC,EAAoBR,EAAeG,GAG/BH,IAAkB1C,EACpBmD,EAAoBX,GACXE,IAAkBhC,GAC3B0C,EAAmBZ,KAIvB,SAAAU,EACER,EACAG,GAIK7C,GAAgB0C,IAAkB1C,EAG3BU,GAAegC,IAAkBhC,IAC3CA,EAAcgC,EACd/B,EAAckC,IAJd7C,EAAe0C,EACfjC,EAAeoC,GAOb7C,GAAgBA,EAAaqD,SAC/BrD,EAAe,KACfS,EAAe,MAEbC,GAAeA,EAAY2C,SAC7B3C,EAAc,KACdC,EAAc,MAIhB2C,EAAkBtD,GAClBsD,EAAkB5C,GAGpB,SAAAyC,EAA6BX,GAC3B,GAAI,OAAQA,EAAIC,KAAM,CAEpB,IAAMc,EAAUf,EAAIC,KACde,EAAWhC,EAAU+B,EAAQ1D,IAC/B2D,IACFA,EAASC,MAAM,KAAMF,EAAQG,aAGtBlC,EAAU+B,EAAQ1D,UAEtB,GAAI,SAAU2C,EAAIC,KAAM,CAEvBc,EAAUf,EAAIC,KAApB,IACMtC,EAAUrB,EAASyE,EAAQI,MAC7BxD,GAEFA,EAAQsD,MAAM/D,KAAM6D,EAAQG,OAKlC,SAAAN,EAA4BZ,GAC1B,GAAI,OAAQA,EAAIC,MAAQ,SAAUD,EAAIC,KAAM,CAE1C,IAAMmB,EAAUpB,EAAIC,KACdtC,EAAUrB,EAAS8E,EAAQD,MACjC,GAAIxD,EAAS,CACX,IAAM0D,EAAS1D,EAAQsD,MAAM/D,KAAMkE,EAAQF,MACvCG,GACFC,EACEpD,EACAkD,EAAQ/D,GACRkE,MAAMC,QAAQH,GAAUA,GAAUA,QAGjC,CAEL,IAAM9B,EAAYhC,EAChBC,EACA4D,EAAQD,KACRC,EAAQF,MAIVlC,EAAUO,GAAa,eAAC,IAAA2B,KAAAtB,EAAA,EAAAA,EAAAC,UAAA9D,OAAA6D,IAAAsB,EAAAtB,GAAAC,UAAAD,GAClB1B,GACFoD,EAAoBpD,EAAakD,EAAQ/D,GAAI6D,MAOvD,SAAAO,EAA+BC,GAC7B,OAAOA,IAAiBlE,EACpBqB,EACA6C,IAAiBxD,EACfY,KAIR,SAAA6C,EAAyBD,GACvB,OAAOA,IAAiBlE,EACpBS,EACAyD,IAAiBxD,EACfC,EACA,KAGR,SAAA2C,EAA2BY,GAGzB,IAFA,IAAME,EAAeD,EAAgBD,GAC/BG,EAAqBJ,EAAsBC,GAC1CA,GAAgBE,GAAgBC,EAAmB9F,OAAS,GACjE2F,EAAaI,YAAYD,EAAmBE,QAASH,GAIzD,SAAAI,EAA6BN,EAAsBV,GACjD,IAAMiB,EAAsBjE,EAAckE,YAAY,WACD,IAA/CT,EAAsBC,GAAc3F,SACtCoG,cAAcF,GACdjB,MAED,KAGL,SAAAzD,EACEmE,EACAU,EAEAlB,GAEA,IAAMmB,EAAUC,EAAqBF,EAAYlB,GACjD,GAAItC,EACEZ,GAAiBA,EAAcuE,iBAChCvE,EAAiCuE,gBAAgBC,qBAChDC,KAAKC,UAAUL,QAGd,CACL,IAAMT,EAAeD,EAAgBD,GAIjCA,GAAgBE,EAClBF,EAAaI,YAAYO,EAAST,GAElCH,EAAsBC,GAAciB,KAAKN,GAG7C,OAAOA,EAAQhF,GAoBjB,SAAAiE,EACEI,EACArE,EAEA6D,GAEA,IAAM0B,EAAWC,EAAsBxF,EAAI6D,GACrCU,EAAeD,EAAgBD,GACjCA,GAAgBE,GAClBF,EAAaI,YAAYc,EAAUhB,GAKvC,SAAAU,EAA8BnB,EAAcD,GAC1C,OACE7D,GAAI0B,IACJoC,KAAMA,EACND,KAAMA,OAKV,SAAA2B,EAA+BxF,EAAY6D,GACzC,OACE7D,GAAIA,EACJ6D,KAAMA,OAxqDV5E,EAAsB,YA0JtB,SAA2BwG,GACrBxE,GACFA,EAAmBwE,GAGjB5E,GACFX,EAAmBW,EAAa,eAAgB4E,KA7JpDxG,EAA2B,iBAgL3B,SAAgCyG,GAC1BxE,GACFA,EAAwBwE,IA/K5BzG,EAA0B,gBAkM1B,WACOkC,GAA2BA,KAC9Bc,KAjMJhD,EAAuB,aAqOvB,WACE,IAAM0G,EAAgB,WACpBzF,EAAmBC,EAAc,qBAG9BiB,GAAwBA,EAAoBuE,IAC/CA,KAxOJ1G,EAAyB,eA0PzB,WACMoC,GACFA,KAtPJ3F,EAAAkK,WAAA,SAA2BC,GACzB,QADyB,IAAAA,MAAA/J,SACrBwF,EAAJ,CAMAA,GAAmB,EAMnB,IAAMwE,EAAkB,SAACnD,GAAsB,OAAAD,EAAeC,KAI9DxC,GAPAQ,EAAgBkF,GAQAE,SAAWpF,EAAcqF,KACnCrF,EAAcoF,OACdpF,EAAcsF,QAOlBtF,EAAcuF,iBAAiB,UAAWJ,GAAiB,IAJ3DvE,GAAoB,EACnBzF,OAA0BqK,gBAAkB7C,GAM/C,IAGE1C,EAAe,IACf,IAAMsB,EAAYhC,EAAmBC,EAAc,cAAehC,IAClEwD,EAAUO,GAAa,SAACkE,EAAiBC,GACvCtF,EAAeqF,EACfpF,EAAiBqF,WAGnBzF,EAAe,KAIjBf,KAAKyG,cAAgB,WACfvF,IACFe,EAA6B,MAC7BC,EAA0B,MAC1BC,EAA0B,MAC1BK,EAA4B,OAG1BtB,IAAiB7B,EAAcC,UACjCA,EAASoH,sBAAsB,MAG7BxF,IAAiB7B,EAAcI,QACjCH,EAASqH,wBAAwB,MAG9BjF,GACHZ,EAAc8F,oBAAoB,UAAWX,GAAiB,GAGhExE,GAAmB,EACnBnB,EAAe,KACfS,EAAe,KACfY,KACAX,EAAc,KACdC,EAAc,KACdW,KACAC,EAAgB,EAChBC,KACAZ,EAAe,KACfC,EAAiB,KACjBO,GAAoB,KAQxB7F,EAAA4K,cAAA,aAIA5K,EAAAgL,sBAAA,WACO9E,IACHA,GAAyB,EACzB3B,IAEA0G,SAAST,iBAAiB,UAAW,SAACU,IAC/BA,EAAMC,SAAWD,EAAME,UAA8B,KAAlBF,EAAMG,UAC5ClF,IACA+E,EAAMI,cAAe,EACrBJ,EAAMK,iBACNL,EAAMM,gCASdxL,EAAAmG,QAQAnG,EAAAyL,WAAA,SAA2BxD,GACzB1D,IAEA,IAAMiC,EAAYhC,EAAmBC,EAAc,cACnDwB,EAAUO,GAAayB,GAQzBjI,EAAAoG,+BAyBApG,EAAAqG,4BAuBArG,EAAAsG,4BAkBAtG,EAAAuG,eAkBAvG,EAAA2G,8BAwBA3G,EAAA0L,8BAAA,SACE9G,GAEAL,EAAkBf,EAAcE,SAEhCiC,EAAwBf,EACxBA,GAAWJ,EAAmBC,EAAc,mBAAoB,oBAkBlEzE,EAAA2L,oBAAA,SAAoChJ,GAClC4B,EACEf,EAAcE,QACdF,EAAcC,SACdD,EAAcI,OACdJ,EAAcK,MAGhB,IAAM2C,EAAYhC,EAAmBC,EAAc,uBACjD9B,IAEFsD,EAAUO,GAAa,SAACC,GACtB,IAAKA,EACH,MAAM,IAAIC,MACR,yGAYR1G,EAAA4L,gBAAA,SACE3D,EACA4D,GAEAtH,IAEA,IAAMiC,EAAYhC,EAAmBC,EAAc,mBACjDoH,IAEF5F,EAAUO,GAAayB,GAWzBjI,EAAA8L,mBAAA,SACE7D,EACA8D,GAEAxH,IAEA,IAAMiC,EAAYhC,EAAmBC,EAAc,sBACjDsH,IAEF9F,EAAUO,GAAayB,GAQzBjI,EAAAgM,mBAAA,SACE/D,EACA4D,GAEAtH,IAEA,IAAMiC,EAAYhC,EAAmBC,EAAc,sBACjDoH,IAEF5F,EAAUO,GAAayB,GAOzBjI,EAAAiM,cAAA,SAA8BC,GAC5B3H,EAAkBf,EAAcE,SAEhCc,EAAmBC,EAAc,iBAC/ByH,EAAmBC,YACnBD,EAAmBE,eACnBF,EAAmBG,mBAWvBrM,EAAAsM,gBAAA,SACEC,GAEAhI,EAAkBf,EAAcE,SAEhC,IAAMsB,GACJuH,EAAsBC,SACtBD,EAAsBE,MACtBF,EAAsBG,YACtBH,EAAsBI,KACtBJ,EAAsBK,UACtBL,EAAsBM,YACtBN,EAAsBO,cACtBP,EAAsBQ,WACtBR,EAAsBS,QACtBT,EAAsBU,SACtBV,EAAsBJ,aAGxB3H,EAAmBC,EAAc,kBAAmBO,IAqBtDhF,EAAAkN,iBAAA,SACEC,GAEA5I,EAAkBf,EAAcE,SAChC,IAAMsB,GACJmI,EAA2BnF,QAC3BmF,EAA2BC,kBAE7B5I,EAAmBC,EAAc,mBAAoBO,IAUvDhF,EAAAqN,gBAAA,SAAgCC,GAC9B/I,EAAkBf,EAAcE,SAChC,IAAM8C,EAAYhC,EAAmBC,EAAc,mBACjD6I,IAEFrH,EAAUO,GAAa,SAACC,EAAkB6B,GACxC,IAAK7B,EACH,MAAM,IAAIC,MAAM4B,KAYtBtI,EAAAuN,gBAAA,SAAgCC,GAC9BjJ,IAEA,IAAMiC,EAAYhC,EAAmBC,EAAc,mBACjD+I,IAEFvH,EAAUO,GAAa,SAACC,EAAkB6B,GACxC,IAAK7B,EACH,MAAM,IAAIC,MAAM4B,KAStBtI,EAAAyN,cAAA,SAA8BC,GAC5BnJ,IAEA,IAAMiC,EAAYhC,EAAmBC,EAAc,iBACjDiJ,IAEFzH,EAAUO,GAAa,SAACC,GACtB,IAAKA,EACH,MAAM,IAAIC,MACR,sEAUR,SAAiBjD,GACf,IAAIkK,EACAC,EACJrK,EAAS,iBAmFT,SAAoB+E,GAClB,IAAMuF,EAAY,IAAIC,EAAcxF,GAChCqF,EACFA,EAAYE,GAGZA,EAAUE,iBAxFdxK,EAAS,mBAmMT,WACE,IAAMyK,EAAc,IAAIC,EACpBL,EACFA,EAAcI,GAGdA,EAAYD,iBAlMAtK,EAAAyK,iBAAhB,SAAiCC,GAC/B5J,EAAkBf,EAAcC,SAAUD,EAAcI,QAExDY,EAAmBC,EAAc,6BAC/B0J,KAQY1K,EAAA2K,YAAhB,SACEnG,GAEA1D,EACEf,EAAcE,QACdF,EAAcC,SACdD,EAAcI,QAGhB,IAAM4C,EAAYhC,EAAmBC,EAAc,wBACnDwB,EAAUO,GAAayB,GAQTxE,EAAA4K,YAAhB,SAA4BC,GAC1B/J,EAAkBf,EAAcE,QAASF,EAAcC,UAEvD,IAAM+C,EAAYhC,EAAmBC,EAAc,wBACjD6J,IAEFrI,EAAUO,GAAa,SAACC,EAAkB6B,GACxC,IAAK7B,EACH,MAAM,IAAIC,MAAM4B,KAYN7E,EAAAoH,sBAAhB,SACEjG,GAEAL,EAAkBf,EAAcC,UAEhCkK,EAAc/I,EACdA,GAAWJ,EAAmBC,EAAc,mBAAoB,UAUlDhB,EAAAqH,wBAAhB,SACElG,GAEAL,EAAkBf,EAAcI,QAEhCgK,EAAgBhJ,EAChBA,GAAWJ,EAAmBC,EAAc,mBAAoB,YAmFlE,IAAAqJ,EAAA,WAIE,SAAAA,EAAYxF,GAHLnE,KAAAoK,UAAoB,EAIzBpK,KAAKmE,OAASA,MA0BlB,OAvBSwF,EAAA1L,UAAA2L,cAAP,WACE5J,KAAKqK,oBAELhK,EAAmBC,EAAc,yBAEjCN,KAAKoK,UAAW,GAGXT,EAAA1L,UAAAqM,cAAP,SAAqBC,GACnBvK,KAAKqK,oBAELhK,EAAmBC,EAAc,yBAA0BiK,IAE3DvK,KAAKoK,UAAW,GAGVT,EAAA1L,UAAAoM,kBAAR,WACE,GAAIrK,KAAKoK,SACP,MAAM,IAAI7H,MACR,2DAIRoH,EA/BA,GA+CA,IAAAG,EAAA,oBAAAA,IACS9J,KAAAoK,UAAoB,EAyB7B,OAvBSN,EAAA7L,UAAA2L,cAAP,WACE5J,KAAKqK,oBAELhK,EAAmBC,EAAc,2BAEjCN,KAAKoK,UAAW,GAGXN,EAAA7L,UAAAqM,cAAP,SAAqBC,GACnBvK,KAAKqK,oBAELhK,EAAmBC,EAAc,2BAA4BiK,IAE7DvK,KAAKoK,UAAW,GAGVN,EAAA7L,UAAAoM,kBAAR,WACE,GAAIrK,KAAKoK,SACP,MAAM,IAAI7H,MACR,6DAIRuH,EA1BA,GArNF,CAAiBxK,EAAAzD,EAAAyD,WAAAzD,EAAAyD,cAsPjB,SAAiBE,GACf,IAAIgL,EACAC,EA0GJ,SAAAC,IAEEC,IAGA,IACM3J,GACFA,EAAY4J,gBAGd5J,EAAc,KACdC,EAAc,MAIlB,SAAA4J,EACEC,GAEAN,EAAaM,EAGbJ,IAGA,IAAIK,EAAQP,EAAWO,OAAS,IAC5BC,EAASR,EAAWQ,QAAU,IAGlCD,EAAQE,KAAKC,IAAIH,EAAOjK,EAAcqK,WAAa,KACnDH,EAASC,KAAKC,IAAIF,EAAQlK,EAAcsK,YAAc,KAGtD,IAAMC,EAAOvE,SAASwE,cAAc,KACpCD,EAAKE,KAAOf,EAAWhM,IAGvB,IAAIgN,OACkC,IAA7B1K,EAAc2K,WACjB3K,EAAc2K,WACd3K,EAAc4K,QAChBC,OACiC,IAA5B7K,EAAc8K,UACjB9K,EAAc8K,UACd9K,EAAc+K,QACpBL,GAAQ1K,EAAcqK,WAAa,EAAIJ,EAAQ,EAC/CY,GAAO7K,EAAcsK,YAAc,EAAIJ,EAAS,GAGhDhK,EAAcF,EAAcgL,KAC1BT,EAAKE,KACL,SACA,wEACAI,EACA,UACAH,EACA,WACAT,EACA,YACAC,IAIAe,IAGAC,EAAc,sBAIlB,SAAArB,IACMF,IACFxF,cAAcwF,GACdA,EAAoB,UAGfrL,EAAqB,kBACrBA,EAA8B,oBAGvC,SAAA2M,IAEEpB,IAOAF,EAAoB3J,EAAckE,YAAY,WAC5C,IAAKhE,GAAeA,EAAY2C,OAC9BqI,EAAc,uBACT,CACL,IAAMC,EAAmBhL,EACzB,IACEA,EAAc,IACdZ,EAAmBW,EAAa,gBAEhCC,EAAcgL,KAGjB,KAGH7M,EAAqB,WAAI,WACvB,OAAQC,EAAcG,eAAgB2B,IAOxC/B,EAA8B,oBAAI,SAACZ,GACjC,OAAO,GA2DX,SAAAwN,EAAuBzB,GACrB,IACMC,GAAcA,EAAW0B,iBAC3B1B,EAAW0B,gBAAgB3B,WAG7BC,EAAa,KACbE,KAUJ,SAAAyB,EACEC,EACAxO,EACAN,GAEA,GAAI8O,EAAa,CACf,IAAMf,EAAOvE,SAASwE,cAAc,KACpCD,EAAKE,KAAOc,mBAAmBD,GAE7Bf,EAAKiB,MACLjB,EAAKiB,OAASrQ,OAAOoH,SAASiJ,MAChB,uBAAdjB,EAAKiB,MACLjB,EAAKkB,OAAOC,QAAQ,8BAAgC,IAEhD5O,GAAe,WAARA,IACLN,IACF+N,EAAKE,KAAOkB,EAAmBpB,EAAKE,KAAM,SAAUjO,IAEtDwD,EAAcuC,SAASqJ,OACrBD,EAAmBpB,EAAKE,KAAM,cAAe,MAG7C3N,GAAe,WAARA,IACLN,IACF+N,EAAKE,KAAOkB,EAAmBpB,EAAKE,KAAM,SAAUjO,IAEtDwD,EAAcuC,SAASqJ,OACrBD,EAAmBpB,EAAKE,KAAM,cAAe,QAavD,SAAAkB,EAA4BE,EAAa/O,EAAaN,GACpD,IAAMjB,EAAIsQ,EAAIH,QAAQ,KAClBI,GAAc,IAAPvQ,EAAW,IAAMsQ,EAAIE,OAAOxQ,GAGvC,OAFAuQ,EAAOA,EAAO,IAAMhP,GAAiB,KAAVN,EAAe,IAAMA,EAAQ,KACxDqP,GAAa,IAAPtQ,EAAWsQ,EAAMA,EAAIE,OAAO,EAAGxQ,IACxBuQ,EAlVfxN,EAAS,uCAyQT,SAAuB+E,GACrB,IACMqG,GAAcA,EAAWsC,iBAC3BtC,EAAWsC,gBAAgB3I,WAG7BqG,EAAa,KACbE,MA/QJtL,EAAS,uCAAyC4M,EAMlCxM,EAAAuN,+BAAhB,SACEjC,GAEAN,EAAaM,GAMCtL,EAAAwN,aAAhB,SACElC,GAEA,IAAMmC,OACuBC,IAA3BpC,EACIA,EACAN,EAQN,GAPApK,EACEf,EAAcE,QACdF,EAAcC,SACdD,EAAcI,OACdJ,EAAcK,MAIA,YAAdyB,GACc,YAAdA,GACc,QAAdA,EACA,CAEA,IAAMkK,EAAOvE,SAASwE,cAAc,KACpCD,EAAKE,KAAO0B,EAAmBzO,IAG/B,IAAM6D,EAAYhC,EAChBC,EACA,+BACC+K,EAAKE,KAAM0B,EAAmBlC,MAAOkC,EAAmBjC,SAE3DlJ,EAAUO,GAAa,SAACC,EAAkBoD,GACpCpD,EACF2K,EAAmBH,gBAAgBpH,GAEnCuH,EAAmBf,gBAAgBxG,SAKvCmF,EAAyBoC,IAYbzN,EAAA2N,aAAhB,SAA6BC,GAC3BhN,IAEA,IAAMiC,EAAYhC,EAChBC,EACA,+BACC8M,EAAiBC,YAEpBvL,EAAUO,GAAa,SAACC,EAAkB6B,GACpC7B,EACF8K,EAAiBN,gBAAgB3I,GAEjCiJ,EAAiBlB,gBAAgB/H,KAWvB3E,EAAA8N,QAAhB,SAAwBC,GACtBnN,IAEA,IAAMiC,EAAYhC,EAChBC,EACA,0BAEFwB,EAAUO,GAAa,SAACC,EAAkB6B,GACpC7B,EACFiL,EAAYT,gBAAgB3I,GAE5BoJ,EAAYrB,gBAAgB/H,KAgIlB3E,EAAAoK,cAAhB,SAA8BzF,EAAiBiI,GAC7CD,EAAuBC,EAAa,SAAUjI,GAE9C/D,EAAkBf,EAAcG,gBAEhCa,EAAmBC,EAAc,uCAC/B6D,IAIFW,EAAoBxE,EAAc,WAChC,OAAAkN,WAAW,WAAM,OAAA1M,EAAc8J,SAAS,QAW5BpL,EAAA8K,cAAhB,SAA8BC,EAAiB6B,GAC7CD,EAAuBC,EAAa,SAAU7B,GAE9CnK,EAAkBf,EAAcG,gBAEhCa,EAAmBC,EAAc,uCAC/BiK,IAIFzF,EAAoBxE,EAAc,WAChC,OAAAkN,WAAW,WAAM,OAAA1M,EAAc8J,SAAS,QAxQ9C,CAAiB/O,EAAA2D,iBAAA3D,EAAA2D,oBA06BjB3D,EAAA4R,kBAAA,SACEvI,EAEAlB,GAGA,OADA5D,IACOC,EAAmBC,EAAc4E,EAAYlB,IA4EtD,SAAiB0J,GAMCA,EAAAC,UAAhB,SACEC,EACAC,GAEAzN,EAAkBf,EAAcE,SAEhC,IAAM8C,EAAYhC,EAAmBC,EAAc,mBACjDsN,IAEF9L,EAAUO,GAAawL,GAOTH,EAAAI,WAAhB,SAA2BF,GACzBxN,EAAkBf,EAAcE,QAASF,EAAcK,MAC/CkO,EAAA7C,MAAO6C,EAAA5C,OAAP,IAAe+C,EAAAC,EAAAJ,GAAA,mBAEvB,GAAK7Q,OAAOkR,KAAKF,GAAOlP,OAGtB,MAAM,IAAI0D,MACR,4EAHFlC,EAAmBC,EAAc,oBAAqBsN,KAa1CF,EAAAQ,WAAhB,SACE/J,EACAgK,GAEA/N,EAAkBf,EAAcE,QAASF,EAAcK,MAGvDW,EAAmBC,EAAc,sBAC/B6D,EACAE,MAAMC,QAAQ6J,GAAUA,GAAUA,MAjDxC,CAAiBtS,EAAA6R,QAAA7R,EAAA6R,WAsFjB7R,EAAAuS,eAAA,SACEtK,GAEA1D,IAEA,IAAMiC,EAAYhC,EAAmBC,EAAc,kBACnDwB,EAAUO,GAAayB","file":"MicrosoftTeams.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"microsoftTeams\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"microsoftTeams\"] = factory();\n\telse\n\t\troot[\"microsoftTeams\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export * from \"./MicrosoftTeams\";\r\n","\"use strict\";\r\n/**\r\n * @private\r\n * Hide from docs\r\n * Shim in definitions used for browser-compat\r\n */\r\ninterface MessageEvent {\r\n  origin?: any;\r\n  source?: any;\r\n  data?: any;\r\n  // Needed for Chrome1964\r\n  originalEvent: MessageEvent;\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs\r\n */\r\ninterface TeamsNativeClient {\r\n  framelessPostMessage(msg: string): void;\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs\r\n */\r\ninterface ExtendedWindow extends Window {\r\n  nativeInterface: TeamsNativeClient;\r\n  onNativeMessage(evt: MessageEvent): void;\r\n}\r\n\r\nconst version = \"1.4.0\";\r\n\r\nconst validOrigins = [\r\n  \"https://teams.microsoft.com\",\r\n  \"https://teams.microsoft.us\",\r\n  \"https://int.teams.microsoft.com\",\r\n  \"https://devspaces.skype.com\",\r\n  \"https://ssauth.skype.com\",\r\n  \"http://dev.local\", // local development\r\n  \"http://dev.local:8080\", // local development\r\n  \"https://msft.spoppe.com\",\r\n  \"https://*.sharepoint.com\",\r\n  \"https://*.sharepoint-df.com\",\r\n  \"https://*.sharepointonline.com\",\r\n  \"https://outlook.office.com\",\r\n  \"https://outlook-sdf.office.com\"\r\n];\r\n\r\n// This will return a reg expression a given url\r\nfunction generateRegExpFromUrl(url: string): string {\r\n  let urlRegExpPart = \"^\";\r\n  const urlParts = url.split(\".\");\r\n  for (let j = 0; j < urlParts.length; j++) {\r\n    urlRegExpPart += (j > 0 ? \"[.]\" : \"\") + urlParts[j].replace(\"*\", \"[^/^.]+\");\r\n  }\r\n  urlRegExpPart += \"$\";\r\n  return urlRegExpPart;\r\n}\r\n\r\n// This will return a reg expression for list of url\r\nfunction generateRegExpFromUrls(urls: string[]): RegExp {\r\n  let urlRegExp = \"\";\r\n  for (let i = 0; i < urls.length; i++) {\r\n    urlRegExp += (i === 0 ? \"\" : \"|\") + generateRegExpFromUrl(urls[i]);\r\n  }\r\n  return new RegExp(urlRegExp);\r\n}\r\n\r\nconst validOriginRegExp = generateRegExpFromUrls(validOrigins);\r\n\r\nconst handlers: { [func: string]: Function } = {};\r\n\r\n// Ensure these declarations stay in sync with the framework.\r\nconst frameContexts = {\r\n  settings: \"settings\",\r\n  content: \"content\",\r\n  authentication: \"authentication\",\r\n  remove: \"remove\",\r\n  task: \"task\"\r\n};\r\n\r\nexport const enum HostClientType {\r\n  desktop = \"desktop\",\r\n  web = \"web\",\r\n  android = \"android\",\r\n  ios = \"ios\"\r\n}\r\n\r\ninterface MessageRequest {\r\n  id: number;\r\n  func: string;\r\n  args?: any[]; // tslint:disable-line:no-any The args here are a passthrough to postMessage where we do allow any[]\r\n}\r\n\r\ninterface MessageResponse {\r\n  id: number;\r\n  args?: any[]; // tslint:disable-line:no-any The args here are a passthrough from OnMessage where we do receive any[]\r\n}\r\n\r\n/**\r\n * Namespace to interact with the menu-specific part of the SDK.\r\n * This object is used to show View Configuration, Action Menu and Navigation Bar Menu.\r\n *\r\n * @private\r\n * Hide from docs until feature is complete\r\n */\r\nexport namespace menus {\r\n  /**\r\n   * Represents information about item in View Configuration.\r\n   */\r\n  export interface ViewConfiguration {\r\n    /**\r\n     * Unique identifier of view.\r\n     */\r\n    id: string;\r\n\r\n    /**\r\n     * Display title of the view.\r\n     */\r\n    title: string;\r\n\r\n    /**\r\n     * Additional information for accessibility.\r\n     */\r\n    contentDescription?: string;\r\n  }\r\n\r\n  /**\r\n   * Represents information about menu item for Action Menu and Navigation Bar Menu.\r\n   */\r\n  export class MenuItem {\r\n    /**\r\n     * Unique identifier for the menu item.\r\n     */\r\n    public id: string;\r\n\r\n    /**\r\n     * Display title of the menu item.\r\n     */\r\n    public title: string;\r\n\r\n    /**\r\n     * Display icon of the menu item. The icon value must be a string having SVG icon content.\r\n     */\r\n    public icon?: string;\r\n\r\n    /**\r\n     * Selected state display icon of the menu item. The icon value must be a string having SVG icon content.\r\n     */\r\n    public iconSelected?: string;\r\n\r\n    /**\r\n     * Additional information for accessibility.\r\n     */\r\n    public contentDescription?: string;\r\n\r\n    /**\r\n     * State of the menu item\r\n     */\r\n    public enabled: boolean = true;\r\n\r\n    /**\r\n     * Interface to show list of items on selection of menu item.\r\n     */\r\n    public viewData: ViewData;\r\n  }\r\n\r\n  /**\r\n   * Represents information about view to show on Navigation Bar Menu item selection\r\n   */\r\n  export interface ViewData {\r\n    /**\r\n     * Display header title of the item list.\r\n     */\r\n    listTitle?: string;\r\n\r\n    /**\r\n     * Type of the menu item.\r\n     */\r\n    listType: MenuListType;\r\n\r\n    /**\r\n     * Array of MenuItem. Icon value will be required for all items in the list.\r\n     */\r\n    listItems: MenuItem[];\r\n  }\r\n\r\n  /**\r\n   * Represents information about type of list to display in Navigation Bar Menu.\r\n   */\r\n  export enum MenuListType {\r\n    dropDown = \"dropDown\",\r\n    popOver = \"popOver\"\r\n  }\r\n\r\n  let navBarMenuItemPressHandler: (id: string) => boolean;\r\n  handlers[\"navBarMenuItemPress\"] = handleNavBarMenuItemPress;\r\n\r\n  let actionMenuItemPressHandler: (id: string) => boolean;\r\n  handlers[\"actionMenuItemPress\"] = handleActionMenuItemPress;\r\n\r\n  let viewConfigItemPressHandler: (id: string) => boolean;\r\n  handlers[\"setModuleView\"] = handleViewConfigItemPress;\r\n\r\n  /**\r\n   * Registers list of view configurations and it's handler.\r\n   * Handler is responsible for listening selection of View Configuration.\r\n   * @param viewConfig List of view configurations. Minimum 1 value is required.\r\n   * @param handler The handler to invoke when the user selects view configuration.\r\n   */\r\n  export function setUpViews(\r\n    viewConfig: ViewConfiguration[],\r\n    handler: (id: string) => boolean\r\n  ): void {\r\n    ensureInitialized();\r\n    viewConfigItemPressHandler = handler;\r\n    sendMessageRequest(parentWindow, \"setUpViews\", [viewConfig]);\r\n  }\r\n\r\n  function handleViewConfigItemPress(id: string): void {\r\n    if (!viewConfigItemPressHandler || !viewConfigItemPressHandler(id)) {\r\n      ensureInitialized();\r\n      sendMessageRequest(parentWindow, \"viewConfigItemPress\", [id]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Used to set menu items on the Navigation Bar. If icon is available, icon will be shown, otherwise title will be shown.\r\n   * @param items List of MenuItems for Navigation Bar Menu.\r\n   * @param handler The handler to invoke when the user selects menu item.\r\n   */\r\n  export function setNavBarMenu(\r\n    items: MenuItem[],\r\n    handler: (id: string) => boolean\r\n  ): void {\r\n    ensureInitialized();\r\n\r\n    navBarMenuItemPressHandler = handler;\r\n    sendMessageRequest(parentWindow, \"setNavBarMenu\", [items]);\r\n  }\r\n\r\n  function handleNavBarMenuItemPress(id: string): void {\r\n    if (!navBarMenuItemPressHandler || !navBarMenuItemPressHandler(id)) {\r\n      ensureInitialized();\r\n      sendMessageRequest(parentWindow, \"handleNavBarMenuItemPress\", [id]);\r\n    }\r\n  }\r\n\r\n  export interface ActionMenuParameters {\r\n    /**\r\n     * Display title for Action Menu\r\n     */\r\n    title: string;\r\n\r\n    /**\r\n     * List of MenuItems for Action Menu\r\n     */\r\n    items: MenuItem[];\r\n  }\r\n\r\n  /**\r\n   * Used to show Action Menu.\r\n   * @param params Parameters for Menu Parameters\r\n   * @param handler The handler to invoke when the user selects menu item.\r\n   */\r\n  export function showActionMenu(\r\n    params: ActionMenuParameters,\r\n    handler: (id: string) => boolean\r\n  ): void {\r\n    ensureInitialized();\r\n\r\n    actionMenuItemPressHandler = handler;\r\n    sendMessageRequest(parentWindow, \"showActionMenu\", [params]);\r\n  }\r\n\r\n  function handleActionMenuItemPress(id: string): void {\r\n    if (!actionMenuItemPressHandler || !actionMenuItemPressHandler(id)) {\r\n      ensureInitialized();\r\n      sendMessageRequest(parentWindow, \"handleActionMenuItemPress\", [id]);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Represents information about tabs for an app\r\n */\r\nexport interface TabInformation {\r\n  teamTabs: TabInstance[];\r\n}\r\n\r\n/**\r\n * Represents information about a tab instance\r\n */\r\nexport interface TabInstance {\r\n  /**\r\n   * The name of the tab\r\n   */\r\n  tabName: string;\r\n\r\n  /**\r\n   * Internal: do not use\r\n   * @protected\r\n   */\r\n  internalTabInstanceId?: string;\r\n\r\n  /**\r\n   * Last viewed time of this tab. null means unknown\r\n   */\r\n  lastViewUnixEpochTime?: string;\r\n\r\n  /**\r\n   * The developer-defined unique ID for the entity this content points to.\r\n   */\r\n  entityId?: string;\r\n\r\n  /**\r\n   * The Microsoft Teams ID for the channel with which the content is associated.\r\n   */\r\n  channelId?: string;\r\n\r\n  /**\r\n   * The name for the channel with which the content is associated.\r\n   */\r\n  channelName?: string;\r\n\r\n  /**\r\n   * Is this tab in a favorite channel?\r\n   */\r\n  channelIsFavorite?: boolean;\r\n\r\n  /**\r\n   * The Microsoft Teams ID for the team with which the content is associated.\r\n   */\r\n  teamId?: string;\r\n\r\n  /**\r\n   * The name for the team with which the content is associated.\r\n   */\r\n  teamName?: string;\r\n\r\n  /**\r\n   * Is this tab in a favorite team?\r\n   */\r\n  teamIsFavorite?: boolean;\r\n\r\n  /**\r\n   * The Office 365 group ID for the team with which the content is associated.\r\n   * This field is available only when the identity permission is requested in the manifest.\r\n   */\r\n  groupId?: string;\r\n\r\n  /**\r\n   * Content URL of this tab\r\n   */\r\n  url?: string;\r\n\r\n  /**\r\n   * Website URL of this tab\r\n   */\r\n  websiteUrl?: string;\r\n}\r\n\r\n/**\r\n * Indicates the team type, currently used to distinguish between different team\r\n * types in Office 365 for Education (team types 1, 2, 3, and 4).\r\n */\r\nexport const enum TeamType {\r\n  Standard = 0,\r\n  Edu = 1,\r\n  Class = 2,\r\n  Plc = 3,\r\n  Staff = 4\r\n}\r\n\r\n/**\r\n * Indicates the various types of roles of a user in a team.\r\n */\r\nexport const enum UserTeamRole {\r\n  Admin = 0,\r\n  User = 1,\r\n  Guest = 2\r\n}\r\n\r\n/**\r\n * Indicates information about the tab instance for filtering purposes.\r\n */\r\nexport interface TabInstanceParameters {\r\n  /**\r\n   * Flag allowing to select favorite channels only\r\n   */\r\n  favoriteChannelsOnly?: boolean;\r\n\r\n  /**\r\n   * Flag allowing to select favorite teams only\r\n   */\r\n  favoriteTeamsOnly?: boolean;\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs\r\n * --------\r\n * Query parameters used when fetching team information\r\n */\r\nexport interface TeamInstanceParameters {\r\n  /**\r\n   * Flag allowing to select favorite teams only\r\n   */\r\n  favoriteTeamsOnly?: boolean;\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs\r\n * --------\r\n * Information on userJoined Teams\r\n */\r\nexport interface UserJoinedTeamsInformation {\r\n  /**\r\n   * List of team information\r\n   */\r\n  userJoinedTeams: TeamInformation[];\r\n}\r\n\r\n/**\r\n * Represents Team Information\r\n */\r\nexport interface TeamInformation {\r\n  /**\r\n   * Id of the team\r\n   */\r\n  teamId: string;\r\n\r\n  /**\r\n   * Team display name\r\n   */\r\n  teamName: string;\r\n\r\n  /**\r\n   * Team description\r\n   */\r\n  teamDescription?: string;\r\n\r\n  /**\r\n   * Thumbnail Uri\r\n   */\r\n  thumbnailUri?: string;\r\n\r\n  /**\r\n   * The Office 365 group ID for the team with which the content is associated.\r\n   * This field is available only when the identity permission is requested in the manifest.\r\n   */\r\n  groupId?: string;\r\n\r\n  /**\r\n   * Role of current user in the team\r\n   */\r\n  userTeamRole?: UserTeamRole;\r\n}\r\n\r\nexport const enum TaskModuleDimension {\r\n  Large = \"large\",\r\n  Medium = \"medium\",\r\n  Small = \"small\"\r\n}\r\n\r\n// This indicates whether initialize was called (started).\r\n// It does not indicate whether initialization is complete. That can be inferred by whether parentOrigin is set.\r\nlet initializeCalled = false;\r\n\r\nlet isFramelessWindow = false;\r\nlet currentWindow: Window | any;\r\nlet parentWindow: Window | any;\r\nlet parentOrigin: string;\r\nlet parentMessageQueue: MessageRequest[] = [];\r\nlet childWindow: Window;\r\nlet childOrigin: string;\r\nlet childMessageQueue: MessageRequest[] = [];\r\nlet nextMessageId = 0;\r\nlet callbacks: { [id: number]: Function } = {};\r\nlet frameContext: string;\r\nlet hostClientType: string;\r\nlet printCapabilityEnabled: boolean = false;\r\n\r\nlet themeChangeHandler: (theme: string) => void;\r\nhandlers[\"themeChange\"] = handleThemeChange;\r\n\r\nlet fullScreenChangeHandler: (isFullScreen: boolean) => void;\r\nhandlers[\"fullScreenChange\"] = handleFullScreenChange;\r\n\r\nlet backButtonPressHandler: () => boolean;\r\nhandlers[\"backButtonPress\"] = handleBackButtonPress;\r\n\r\nlet beforeUnloadHandler: (readyToUnload: () => void) => boolean;\r\nhandlers[\"beforeUnload\"] = handleBeforeUnload;\r\n\r\nlet changeSettingsHandler: () => void;\r\nhandlers[\"changeSettings\"] = handleChangeSettings;\r\n\r\n/**\r\n * Initializes the library. This must be called before any other SDK calls\r\n * but after the frame is loaded successfully.\r\n */\r\nexport function initialize(hostWindow: any = window): void {\r\n  if (initializeCalled) {\r\n    // Independent components might not know whether the SDK is initialized so might call it to be safe.\r\n    // Just no-op if that happens to make it easier to use.\r\n    return;\r\n  }\r\n\r\n  initializeCalled = true;\r\n\r\n  // Undocumented field used to mock the window for unit tests\r\n  currentWindow = hostWindow;\r\n\r\n  // Listen for messages post to our window\r\n  const messageListener = (evt: MessageEvent) => processMessage(evt);\r\n\r\n  // If we are in an iframe, our parent window is the one hosting us (i.e., window.parent); otherwise,\r\n  // it's the window that opened us (i.e., window.opener)\r\n  parentWindow =\r\n    currentWindow.parent !== currentWindow.self\r\n      ? currentWindow.parent\r\n      : currentWindow.opener;\r\n\r\n  if (!parentWindow) {\r\n    isFramelessWindow = true;\r\n    (window as ExtendedWindow).onNativeMessage = handleParentMessage;\r\n  } else {\r\n    // For iFrame scenario, add listener to listen 'message'\r\n    currentWindow.addEventListener(\"message\", messageListener, false);\r\n  }\r\n\r\n  try {\r\n    // Send the initialized message to any origin, because at this point we most likely don't know the origin\r\n    // of the parent window, and this message contains no data that could pose a security risk.\r\n    parentOrigin = \"*\";\r\n    const messageId = sendMessageRequest(parentWindow, \"initialize\", [version]);\r\n    callbacks[messageId] = (context: string, clientType: string) => {\r\n      frameContext = context;\r\n      hostClientType = clientType;\r\n    };\r\n  } finally {\r\n    parentOrigin = null;\r\n  }\r\n\r\n  // Undocumented function used to clear state between unit tests\r\n  this._uninitialize = () => {\r\n    if (frameContext) {\r\n      registerOnThemeChangeHandler(null);\r\n      registerFullScreenHandler(null);\r\n      registerBackButtonHandler(null);\r\n      registerBeforeUnloadHandler(null);\r\n    }\r\n\r\n    if (frameContext === frameContexts.settings) {\r\n      settings.registerOnSaveHandler(null);\r\n    }\r\n\r\n    if (frameContext === frameContexts.remove) {\r\n      settings.registerOnRemoveHandler(null);\r\n    }\r\n\r\n    if (!isFramelessWindow) {\r\n      currentWindow.removeEventListener(\"message\", messageListener, false);\r\n    }\r\n\r\n    initializeCalled = false;\r\n    parentWindow = null;\r\n    parentOrigin = null;\r\n    parentMessageQueue = [];\r\n    childWindow = null;\r\n    childOrigin = null;\r\n    childMessageQueue = [];\r\n    nextMessageId = 0;\r\n    callbacks = {};\r\n    frameContext = null;\r\n    hostClientType = null;\r\n    isFramelessWindow = false;\r\n  };\r\n}\r\n\r\n/**\r\n * Initializes the library. This must be called before any other SDK calls\r\n * but after the frame is loaded successfully.\r\n */\r\nexport function _uninitialize(): void { }\r\n/**\r\n * Enable print capability to support printing page using Ctrl+P and cmd+P\r\n */\r\nexport function enablePrintCapability(): void {\r\n  if (!printCapabilityEnabled) {\r\n    printCapabilityEnabled = true;\r\n    ensureInitialized();\r\n    // adding ctrl+P and cmd+P handler\r\n    document.addEventListener(\"keydown\", (event: KeyboardEvent) => {\r\n      if ((event.ctrlKey || event.metaKey) && event.keyCode === 80) {\r\n        print();\r\n        event.cancelBubble = true;\r\n        event.preventDefault();\r\n        event.stopImmediatePropagation();\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * default print handler\r\n */\r\nexport function print(): void {\r\n  window.print();\r\n}\r\n\r\n/**\r\n * Retrieves the current context the frame is running in.\r\n * @param callback The callback to invoke when the {@link Context} object is retrieved.\r\n */\r\nexport function getContext(callback: (context: Context) => void): void {\r\n  ensureInitialized();\r\n\r\n  const messageId = sendMessageRequest(parentWindow, \"getContext\");\r\n  callbacks[messageId] = callback;\r\n}\r\n\r\n/**\r\n * Registers a handler for theme changes.\r\n * Only one handler can be registered at a time. A subsequent registration replaces an existing registration.\r\n * @param handler The handler to invoke when the user changes their theme.\r\n */\r\nexport function registerOnThemeChangeHandler(\r\n  handler: (theme: string) => void\r\n): void {\r\n  ensureInitialized();\r\n\r\n  themeChangeHandler = handler;\r\n  handler &&\r\n    sendMessageRequest(parentWindow, \"registerHandler\", [\"themeChange\"]);\r\n}\r\n\r\nfunction handleThemeChange(theme: string): void {\r\n  if (themeChangeHandler) {\r\n    themeChangeHandler(theme);\r\n  }\r\n\r\n  if (childWindow) {\r\n    sendMessageRequest(childWindow, \"themeChange\", [theme]);\r\n  }\r\n}\r\n\r\n/**\r\n * Registers a handler for changes from or to full-screen view for a tab.\r\n * Only one handler can be registered at a time. A subsequent registration replaces an existing registration.\r\n * @param handler The handler to invoke when the user toggles full-screen view for a tab.\r\n */\r\nexport function registerFullScreenHandler(\r\n  handler: (isFullScreen: boolean) => void\r\n): void {\r\n  ensureInitialized();\r\n\r\n  fullScreenChangeHandler = handler;\r\n  handler &&\r\n    sendMessageRequest(parentWindow, \"registerHandler\", [\"fullScreen\"]);\r\n}\r\n\r\nfunction handleFullScreenChange(isFullScreen: boolean): void {\r\n  if (fullScreenChangeHandler) {\r\n    fullScreenChangeHandler(isFullScreen);\r\n  }\r\n}\r\n\r\n/**\r\n * Registers a handler for user presses of the Team client's back button. Experiences that maintain an internal\r\n * navigation stack should use this handler to navigate the user back within their frame. If an app finds\r\n * that after running its back button handler it cannot handle the event it should call the navigateBack\r\n * method to ask the Teams client to handle it instead.\r\n * @param handler The handler to invoke when the user presses their Team client's back button.\r\n */\r\nexport function registerBackButtonHandler(handler: () => boolean): void {\r\n  ensureInitialized();\r\n\r\n  backButtonPressHandler = handler;\r\n  handler &&\r\n    sendMessageRequest(parentWindow, \"registerHandler\", [\"backButton\"]);\r\n}\r\n\r\nfunction handleBackButtonPress(): void {\r\n  if (!backButtonPressHandler || !backButtonPressHandler()) {\r\n    navigateBack();\r\n  }\r\n}\r\n\r\n/**\r\n * Navigates back in the Teams client. See registerBackButtonHandler for more information on when\r\n * it's appropriate to use this method.\r\n */\r\nexport function navigateBack(): void {\r\n  ensureInitialized();\r\n\r\n  const messageId = sendMessageRequest(parentWindow, \"navigateBack\", []);\r\n  callbacks[messageId] = (success: boolean) => {\r\n    if (!success) {\r\n      throw new Error(\r\n        \"Back navigation is not supported in the current client or context.\"\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Registers a handler to be called before the page is unloaded.\r\n * @param handler The handler to invoke before the page is unloaded. If this handler returns true the page should\r\n * invoke the readyToUnload function provided to it once it's ready to be unloaded.\r\n */\r\nexport function registerBeforeUnloadHandler(\r\n  handler: (readyToUnload: () => void) => boolean\r\n): void {\r\n  ensureInitialized();\r\n\r\n  beforeUnloadHandler = handler;\r\n  handler &&\r\n    sendMessageRequest(parentWindow, \"registerHandler\", [\"beforeUnload\"]);\r\n}\r\n\r\nfunction handleBeforeUnload(): void {\r\n  const readyToUnload = () => {\r\n    sendMessageRequest(parentWindow, \"readyToUnload\", []);\r\n  };\r\n\r\n  if (!beforeUnloadHandler || !beforeUnloadHandler(readyToUnload)) {\r\n    readyToUnload();\r\n  }\r\n}\r\n\r\n/**\r\n * Registers a handler for when the user reconfigurated tab\r\n * @param handler The handler to invoke when the user click on Settings.\r\n */\r\nexport function registerChangeSettingsHandler(\r\n  handler: () => void\r\n): void {\r\n  ensureInitialized(frameContexts.content);\r\n\r\n  changeSettingsHandler = handler;\r\n  handler && sendMessageRequest(parentWindow, \"registerHandler\", [\"changeSettings\"]);\r\n}\r\n\r\n\r\nfunction handleChangeSettings(): void {\r\n  if (changeSettingsHandler) {\r\n    changeSettingsHandler();\r\n  }\r\n}\r\n\r\n/**\r\n * Navigates the frame to a new cross-domain URL. The domain of this URL must match at least one of the\r\n * valid domains specified in the validDomains block of the manifest; otherwise, an exception will be\r\n * thrown. This function needs to be used only when navigating the frame to a URL in a different domain\r\n * than the current one in a way that keeps the app informed of the change and allows the SDK to\r\n * continue working.\r\n * @param url The URL to navigate the frame to.\r\n */\r\nexport function navigateCrossDomain(url: string): void {\r\n  ensureInitialized(\r\n    frameContexts.content,\r\n    frameContexts.settings,\r\n    frameContexts.remove,\r\n    frameContexts.task\r\n  );\r\n\r\n  const messageId = sendMessageRequest(parentWindow, \"navigateCrossDomain\", [\r\n    url\r\n  ]);\r\n  callbacks[messageId] = (success: boolean) => {\r\n    if (!success) {\r\n      throw new Error(\r\n        \"Cross-origin navigation is only supported for URLs matching the pattern registered in the manifest.\"\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Allows an app to retrieve for this user tabs that are owned by this app.\r\n * If no TabInstanceParameters are passed, the app defaults to favorite teams and favorite channels.\r\n * @param callback The callback to invoke when the {@link TabInstanceParameters} object is retrieved.\r\n * @param tabInstanceParameters OPTIONAL Flags that specify whether to scope call to favorite teams or channels.\r\n */\r\nexport function getTabInstances(\r\n  callback: (tabInfo: TabInformation) => void,\r\n  tabInstanceParameters?: TabInstanceParameters\r\n): void {\r\n  ensureInitialized();\r\n\r\n  const messageId = sendMessageRequest(parentWindow, \"getTabInstances\", [\r\n    tabInstanceParameters\r\n  ]);\r\n  callbacks[messageId] = callback;\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs\r\n * ------\r\n * Allows an app to retrieve information of all user joined teams\r\n * @param callback The callback to invoke when the {@link TeamInstanceParameters} object is retrieved.\r\n * @param teamInstanceParameters OPTIONAL Flags that specify whether to scope call to favorite teams\r\n */\r\nexport function getUserJoinedTeams(\r\n  callback: (userJoinedTeamsInformation: UserJoinedTeamsInformation) => void,\r\n  teamInstanceParameters?: TeamInstanceParameters\r\n): void {\r\n  ensureInitialized();\r\n\r\n  const messageId = sendMessageRequest(parentWindow, \"getUserJoinedTeams\", [\r\n    teamInstanceParameters\r\n  ]);\r\n  callbacks[messageId] = callback;\r\n}\r\n\r\n/**\r\n * Allows an app to retrieve the most recently used tabs for this user.\r\n * @param callback The callback to invoke when the {@link TabInformation} object is retrieved.\r\n * @param tabInstanceParameters OPTIONAL Ignored, kept for future use\r\n */\r\nexport function getMruTabInstances(\r\n  callback: (tabInfo: TabInformation) => void,\r\n  tabInstanceParameters?: TabInstanceParameters\r\n): void {\r\n  ensureInitialized();\r\n\r\n  const messageId = sendMessageRequest(parentWindow, \"getMruTabInstances\", [\r\n    tabInstanceParameters\r\n  ]);\r\n  callbacks[messageId] = callback;\r\n}\r\n\r\n/**\r\n * Shares a deep link that a user can use to navigate back to a specific state in this page.\r\n * @param deepLinkParameters ID and label for the link and fallback URL.\r\n */\r\nexport function shareDeepLink(deepLinkParameters: DeepLinkParameters): void {\r\n  ensureInitialized(frameContexts.content);\r\n\r\n  sendMessageRequest(parentWindow, \"shareDeepLink\", [\r\n    deepLinkParameters.subEntityId,\r\n    deepLinkParameters.subEntityLabel,\r\n    deepLinkParameters.subEntityWebUrl\r\n  ]);\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs.\r\n * ------\r\n * Opens a client-friendly preview of the specified file.\r\n * @param file The file to preview.\r\n */\r\nexport function openFilePreview(\r\n  filePreviewParameters: FilePreviewParameters\r\n): void {\r\n  ensureInitialized(frameContexts.content);\r\n\r\n  const params = [\r\n    filePreviewParameters.entityId,\r\n    filePreviewParameters.title,\r\n    filePreviewParameters.description,\r\n    filePreviewParameters.type,\r\n    filePreviewParameters.objectUrl,\r\n    filePreviewParameters.downloadUrl,\r\n    filePreviewParameters.webPreviewUrl,\r\n    filePreviewParameters.webEditUrl,\r\n    filePreviewParameters.baseUrl,\r\n    filePreviewParameters.editFile,\r\n    filePreviewParameters.subEntityId\r\n  ];\r\n\r\n  sendMessageRequest(parentWindow, \"openFilePreview\", params);\r\n}\r\n\r\nexport const enum NotificationTypes {\r\n  fileDownloadStart = \"fileDownloadStart\",\r\n  fileDownloadComplete = \"fileDownloadComplete\"\r\n}\r\n\r\nexport interface ShowNotificationParameters {\r\n  message: string;\r\n  notificationType: NotificationTypes;\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs.\r\n * ------\r\n * display notification API.\r\n * @param message Notification message.\r\n * @param notificationType Notification type\r\n */\r\nexport function showNotification(\r\n  showNotificationParameters: ShowNotificationParameters\r\n): void {\r\n  ensureInitialized(frameContexts.content);\r\n  const params = [\r\n    showNotificationParameters.message,\r\n    showNotificationParameters.notificationType\r\n  ];\r\n  sendMessageRequest(parentWindow, \"showNotification\", params);\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs.\r\n * ------\r\n * execute deep link API.\r\n * @param deepLink deep link.\r\n */\r\nexport function executeDeepLink(deepLink: string): void {\r\n  ensureInitialized(frameContexts.content);\r\n  const messageId = sendMessageRequest(parentWindow, \"executeDeepLink\", [\r\n    deepLink\r\n  ]);\r\n  callbacks[messageId] = (success: boolean, result: string) => {\r\n    if (!success) {\r\n      throw new Error(result);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs.\r\n * ------\r\n * Upload a custom App manifest directly to both team and personal scopes.\r\n * This method works just for the first party Apps.\r\n */\r\nexport function uploadCustomApp(manifestBlob: Blob): void {\r\n  ensureInitialized();\r\n\r\n  const messageId = sendMessageRequest(parentWindow, \"uploadCustomApp\", [\r\n    manifestBlob\r\n  ]);\r\n  callbacks[messageId] = (success: boolean, result: string) => {\r\n    if (!success) {\r\n      throw new Error(result);\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Navigates the Microsoft Teams app to the specified tab instance.\r\n * @param tabInstance The tab instance to navigate to.\r\n */\r\nexport function navigateToTab(tabInstance: TabInstance): void {\r\n  ensureInitialized();\r\n\r\n  const messageId = sendMessageRequest(parentWindow, \"navigateToTab\", [\r\n    tabInstance\r\n  ]);\r\n  callbacks[messageId] = (success: boolean) => {\r\n    if (!success) {\r\n      throw new Error(\r\n        \"Invalid internalTabInstanceId and/or channelId were/was provided\"\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Namespace to interact with the settings-specific part of the SDK.\r\n * This object is usable only on the settings frame.\r\n */\r\nexport namespace settings {\r\n  let saveHandler: (evt: SaveEvent) => void;\r\n  let removeHandler: (evt: RemoveEvent) => void;\r\n  handlers[\"settings.save\"] = handleSave;\r\n  handlers[\"settings.remove\"] = handleRemove;\r\n\r\n  /**\r\n   * Sets the validity state for the settings.\r\n   * The initial value is false, so the user cannot save the settings until this is called with true.\r\n   * @param validityState Indicates whether the save or remove button is enabled for the user.\r\n   */\r\n  export function setValidityState(validityState: boolean): void {\r\n    ensureInitialized(frameContexts.settings, frameContexts.remove);\r\n\r\n    sendMessageRequest(parentWindow, \"settings.setValidityState\", [\r\n      validityState\r\n    ]);\r\n  }\r\n\r\n  /**\r\n   * Gets the settings for the current instance.\r\n   * @param callback The callback to invoke when the {@link Settings} object is retrieved.\r\n   */\r\n  export function getSettings(\r\n    callback: (instanceSettings: Settings) => void\r\n  ): void {\r\n    ensureInitialized(\r\n      frameContexts.content,\r\n      frameContexts.settings,\r\n      frameContexts.remove\r\n    );\r\n\r\n    const messageId = sendMessageRequest(parentWindow, \"settings.getSettings\");\r\n    callbacks[messageId] = callback;\r\n  }\r\n\r\n  /**\r\n   * Sets the settings for the current instance.\r\n   * This is an asynchronous operation; calls to getSettings are not guaranteed to reflect the changed state.\r\n   * @param settings The desired settings for this instance.\r\n   */\r\n  export function setSettings(instanceSettings: Settings): void {\r\n    ensureInitialized(frameContexts.content, frameContexts.settings);\r\n\r\n    const messageId = sendMessageRequest(parentWindow, \"settings.setSettings\", [\r\n      instanceSettings\r\n    ]);\r\n    callbacks[messageId] = (success: boolean, result: string) => {\r\n      if (!success) {\r\n        throw new Error(result);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Registers a handler for when the user attempts to save the settings. This handler should be used\r\n   * to create or update the underlying resource powering the content.\r\n   * The object passed to the handler must be used to notify whether to proceed with the save.\r\n   * Only one handler can be registered at a time. A subsequent registration replaces an existing registration.\r\n   * @param handler The handler to invoke when the user selects the save button.\r\n   */\r\n  export function registerOnSaveHandler(\r\n    handler: (evt: SaveEvent) => void\r\n  ): void {\r\n    ensureInitialized(frameContexts.settings);\r\n\r\n    saveHandler = handler;\r\n    handler && sendMessageRequest(parentWindow, \"registerHandler\", [\"save\"]);\r\n  }\r\n\r\n  /**\r\n   * Registers a handler for user attempts to remove content. This handler should be used\r\n   * to remove the underlying resource powering the content.\r\n   * The object passed to the handler must be used to indicate whether to proceed with the removal.\r\n   * Only one handler may be registered at a time. Subsequent registrations will override the first.\r\n   * @param handler The handler to invoke when the user selects the remove button.\r\n   */\r\n  export function registerOnRemoveHandler(\r\n    handler: (evt: RemoveEvent) => void\r\n  ): void {\r\n    ensureInitialized(frameContexts.remove);\r\n\r\n    removeHandler = handler;\r\n    handler && sendMessageRequest(parentWindow, \"registerHandler\", [\"remove\"]);\r\n  }\r\n\r\n  function handleSave(result?: SaveParameters): void {\r\n    const saveEvent = new SaveEventImpl(result);\r\n    if (saveHandler) {\r\n      saveHandler(saveEvent);\r\n    } else {\r\n      // If no handler is registered, we assume success.\r\n      saveEvent.notifySuccess();\r\n    }\r\n  }\r\n\r\n  export interface Settings {\r\n    /**\r\n     * A suggested display name for the new content.\r\n     * In the settings for an existing instance being updated, this call has no effect.\r\n     */\r\n    suggestedDisplayName?: string;\r\n\r\n    /**\r\n     * Sets the URL to use for the content of this instance.\r\n     */\r\n    contentUrl: string;\r\n\r\n    /**\r\n     * Sets the URL for the removal configuration experience.\r\n     */\r\n    removeUrl?: string;\r\n\r\n    /**\r\n     * Sets the URL to use for the external link to view the underlying resource in a browser.\r\n     */\r\n    websiteUrl?: string;\r\n\r\n    /**\r\n     * The developer-defined unique ID for the entity to which this content points.\r\n     */\r\n    entityId: string;\r\n  }\r\n\r\n  export interface SaveEvent {\r\n    /**\r\n     * Object containing properties passed as arguments to the settings.save event.\r\n     */\r\n    result: SaveParameters;\r\n\r\n    /**\r\n     * Indicates that the underlying resource has been created and the settings can be saved.\r\n     */\r\n    notifySuccess(): void;\r\n\r\n    /**\r\n     * Indicates that creation of the underlying resource failed and that the settings cannot be saved.\r\n     * @param reason Specifies a reason for the failure. If provided, this string is displayed to the user; otherwise a generic error is displayed.\r\n     */\r\n    notifyFailure(reason?: string): void;\r\n  }\r\n\r\n  export interface RemoveEvent {\r\n    /**\r\n     * Indicates that the underlying resource has been removed and the content can be removed.\r\n     */\r\n    notifySuccess(): void;\r\n\r\n    /**\r\n     * Indicates that removal of the underlying resource failed and that the content cannot be removed.\r\n     * @param reason Specifies a reason for the failure. If provided, this string is displayed to the user; otherwise a generic error is displayed.\r\n     */\r\n    notifyFailure(reason?: string): void;\r\n  }\r\n\r\n  export interface SaveParameters {\r\n    /**\r\n     * Connector's webhook Url returned as arguments to settings.save event as part of user clicking on Save\r\n     */\r\n    webhookUrl?: string;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Hide from docs, since this class is not directly used.\r\n   */\r\n  class SaveEventImpl implements SaveEvent {\r\n    public notified: boolean = false;\r\n    public result: SaveParameters;\r\n\r\n    constructor(result?: SaveParameters) {\r\n      this.result = result ? result : {};\r\n    }\r\n\r\n    public notifySuccess(): void {\r\n      this.ensureNotNotified();\r\n\r\n      sendMessageRequest(parentWindow, \"settings.save.success\");\r\n\r\n      this.notified = true;\r\n    }\r\n\r\n    public notifyFailure(reason?: string): void {\r\n      this.ensureNotNotified();\r\n\r\n      sendMessageRequest(parentWindow, \"settings.save.failure\", [reason]);\r\n\r\n      this.notified = true;\r\n    }\r\n\r\n    private ensureNotNotified(): void {\r\n      if (this.notified) {\r\n        throw new Error(\r\n          \"The SaveEvent may only notify success or failure once.\"\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  function handleRemove(): void {\r\n    const removeEvent = new RemoveEventImpl();\r\n    if (removeHandler) {\r\n      removeHandler(removeEvent);\r\n    } else {\r\n      // If no handler is registered, we assume success.\r\n      removeEvent.notifySuccess();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Hide from docs, since this class is not directly used.\r\n   */\r\n  class RemoveEventImpl implements RemoveEvent {\r\n    public notified: boolean = false;\r\n\r\n    public notifySuccess(): void {\r\n      this.ensureNotNotified();\r\n\r\n      sendMessageRequest(parentWindow, \"settings.remove.success\");\r\n\r\n      this.notified = true;\r\n    }\r\n\r\n    public notifyFailure(reason?: string): void {\r\n      this.ensureNotNotified();\r\n\r\n      sendMessageRequest(parentWindow, \"settings.remove.failure\", [reason]);\r\n\r\n      this.notified = true;\r\n    }\r\n\r\n    private ensureNotNotified(): void {\r\n      if (this.notified) {\r\n        throw new Error(\r\n          \"The removeEvent may only notify success or failure once.\"\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Namespace to interact with the authentication-specific part of the SDK.\r\n * This object is used for starting or completing authentication flows.\r\n */\r\nexport namespace authentication {\r\n  let authParams: AuthenticateParameters;\r\n  let authWindowMonitor: number;\r\n  handlers[\"authentication.authenticate.success\"] = handleSuccess;\r\n  handlers[\"authentication.authenticate.failure\"] = handleFailure;\r\n\r\n  /**\r\n   * Registers the authentication handlers\r\n   * @param authenticateParameters A set of values that configure the authentication pop-up.\r\n   */\r\n  export function registerAuthenticationHandlers(\r\n    authenticateParameters: AuthenticateParameters\r\n  ): void {\r\n    authParams = authenticateParameters;\r\n  }\r\n\r\n  /**\r\n   * Initiates an authentication request, which opens a new window with the specified settings.\r\n   */\r\n  export function authenticate(\r\n    authenticateParameters?: AuthenticateParameters\r\n  ): void {\r\n    const authenticateParams =\r\n      authenticateParameters !== undefined\r\n        ? authenticateParameters\r\n        : authParams;\r\n    ensureInitialized(\r\n      frameContexts.content,\r\n      frameContexts.settings,\r\n      frameContexts.remove,\r\n      frameContexts.task\r\n    );\r\n\r\n    if (\r\n      hostClientType === HostClientType.desktop ||\r\n      hostClientType === HostClientType.android ||\r\n      hostClientType === HostClientType.ios\r\n    ) {\r\n      // Convert any relative URLs into absolute URLs before sending them over to the parent window.\r\n      const link = document.createElement(\"a\");\r\n      link.href = authenticateParams.url;\r\n\r\n      // Ask the parent window to open an authentication window with the parameters provided by the caller.\r\n      const messageId = sendMessageRequest(\r\n        parentWindow,\r\n        \"authentication.authenticate\",\r\n        [link.href, authenticateParams.width, authenticateParams.height]\r\n      );\r\n      callbacks[messageId] = (success: boolean, response: string) => {\r\n        if (success) {\r\n          authenticateParams.successCallback(response);\r\n        } else {\r\n          authenticateParams.failureCallback(response);\r\n        }\r\n      };\r\n    } else {\r\n      // Open an authentication window with the parameters provided by the caller.\r\n      openAuthenticationWindow(authenticateParams);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Hide from docs.\r\n   * ------\r\n   * Requests an Azure AD token to be issued on behalf of the app. The token is acquired from the cache\r\n   * if it is not expired. Otherwise a request is sent to Azure AD to obtain a new token.\r\n   * @param authTokenRequest A set of values that configure the token request.\r\n   */\r\n  export function getAuthToken(authTokenRequest: AuthTokenRequest): void {\r\n    ensureInitialized();\r\n\r\n    const messageId = sendMessageRequest(\r\n      parentWindow,\r\n      \"authentication.getAuthToken\",\r\n      [authTokenRequest.resources]\r\n    );\r\n    callbacks[messageId] = (success: boolean, result: string) => {\r\n      if (success) {\r\n        authTokenRequest.successCallback(result);\r\n      } else {\r\n        authTokenRequest.failureCallback(result);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Hide from docs.\r\n   * ------\r\n   * Requests the decoded Azure AD user identity on behalf of the app.\r\n   */\r\n  export function getUser(userRequest: UserRequest): void {\r\n    ensureInitialized();\r\n\r\n    const messageId = sendMessageRequest(\r\n      parentWindow,\r\n      \"authentication.getUser\"\r\n    );\r\n    callbacks[messageId] = (success: boolean, result: UserProfile | string) => {\r\n      if (success) {\r\n        userRequest.successCallback(result as UserProfile);\r\n      } else {\r\n        userRequest.failureCallback(result as string);\r\n      }\r\n    };\r\n  }\r\n\r\n  function closeAuthenticationWindow(): void {\r\n    // Stop monitoring the authentication window\r\n    stopAuthenticationWindowMonitor();\r\n\r\n    // Try to close the authentication window and clear all properties associated with it\r\n    try {\r\n      if (childWindow) {\r\n        childWindow.close();\r\n      }\r\n    } finally {\r\n      childWindow = null;\r\n      childOrigin = null;\r\n    }\r\n  }\r\n\r\n  function openAuthenticationWindow(\r\n    authenticateParameters: AuthenticateParameters\r\n  ): void {\r\n    authParams = authenticateParameters;\r\n\r\n    // Close the previously opened window if we have one\r\n    closeAuthenticationWindow();\r\n\r\n    // Start with a sensible default size\r\n    let width = authParams.width || 600;\r\n    let height = authParams.height || 400;\r\n\r\n    // Ensure that the new window is always smaller than our app's window so that it never fully covers up our app\r\n    width = Math.min(width, currentWindow.outerWidth - 400);\r\n    height = Math.min(height, currentWindow.outerHeight - 200);\r\n\r\n    // Convert any relative URLs into absolute URLs before sending them over to the parent window\r\n    const link = document.createElement(\"a\");\r\n    link.href = authParams.url;\r\n\r\n    // We are running in the browser, so we need to center the new window ourselves\r\n    let left: number =\r\n      typeof currentWindow.screenLeft !== \"undefined\"\r\n        ? currentWindow.screenLeft\r\n        : currentWindow.screenX;\r\n    let top: number =\r\n      typeof currentWindow.screenTop !== \"undefined\"\r\n        ? currentWindow.screenTop\r\n        : currentWindow.screenY;\r\n    left += currentWindow.outerWidth / 2 - width / 2;\r\n    top += currentWindow.outerHeight / 2 - height / 2;\r\n\r\n    // Open a child window with a desired set of standard browser features\r\n    childWindow = currentWindow.open(\r\n      link.href,\r\n      \"_blank\",\r\n      \"toolbar=no, location=yes, status=no, menubar=no, scrollbars=yes, top=\" +\r\n      top +\r\n      \", left=\" +\r\n      left +\r\n      \", width=\" +\r\n      width +\r\n      \", height=\" +\r\n      height\r\n    );\r\n    if (childWindow) {\r\n      // Start monitoring the authentication window so that we can detect if it gets closed before the flow completes\r\n      startAuthenticationWindowMonitor();\r\n    } else {\r\n      // If we failed to open the window, fail the authentication flow\r\n      handleFailure(\"FailedToOpenWindow\");\r\n    }\r\n  }\r\n\r\n  function stopAuthenticationWindowMonitor(): void {\r\n    if (authWindowMonitor) {\r\n      clearInterval(authWindowMonitor);\r\n      authWindowMonitor = 0;\r\n    }\r\n\r\n    delete handlers[\"initialize\"];\r\n    delete handlers[\"navigateCrossDomain\"];\r\n  }\r\n\r\n  function startAuthenticationWindowMonitor(): void {\r\n    // Stop the previous window monitor if one is running\r\n    stopAuthenticationWindowMonitor();\r\n\r\n    // Create an interval loop that\r\n    // - Notifies the caller of failure if it detects that the authentication window is closed\r\n    // - Keeps pinging the authentication window while it is open to re-establish\r\n    //   contact with any pages along the authentication flow that need to communicate\r\n    //   with us\r\n    authWindowMonitor = currentWindow.setInterval(() => {\r\n      if (!childWindow || childWindow.closed) {\r\n        handleFailure(\"CancelledByUser\");\r\n      } else {\r\n        const savedChildOrigin = childOrigin;\r\n        try {\r\n          childOrigin = \"*\";\r\n          sendMessageRequest(childWindow, \"ping\");\r\n        } finally {\r\n          childOrigin = savedChildOrigin;\r\n        }\r\n      }\r\n    }, 100);\r\n\r\n    // Set up an initialize-message handler that gives the authentication window its frame context\r\n    handlers[\"initialize\"] = () => {\r\n      return [frameContexts.authentication, hostClientType];\r\n    };\r\n\r\n    // Set up a navigateCrossDomain message handler that blocks cross-domain re-navigation attempts\r\n    // in the authentication window. We could at some point choose to implement this method via a call to\r\n    // authenticationWindow.location.href = url; however, we would first need to figure out how to\r\n    // validate the URL against the tab's list of valid domains.\r\n    handlers[\"navigateCrossDomain\"] = (url: string) => {\r\n      return false;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Notifies the frame that initiated this authentication request that the request was successful.\r\n   * This function is usable only on the authentication window.\r\n   * This call causes the authentication window to be closed.\r\n   * @param result Specifies a result for the authentication. If specified, the frame that initiated the authentication pop-up receives this value in its callback.\r\n   * @param callbackUrl Specifies the url to redirect back to if the client is Win32 Outlook.\r\n   */\r\n  export function notifySuccess(result?: string, callbackUrl?: string): void {\r\n    redirectIfWin32Outlook(callbackUrl, \"result\", result);\r\n\r\n    ensureInitialized(frameContexts.authentication);\r\n\r\n    sendMessageRequest(parentWindow, \"authentication.authenticate.success\", [\r\n      result\r\n    ]);\r\n\r\n    // Wait for the message to be sent before closing the window\r\n    waitForMessageQueue(parentWindow, () =>\r\n      setTimeout(() => currentWindow.close(), 200)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Notifies the frame that initiated this authentication request that the request failed.\r\n   * This function is usable only on the authentication window.\r\n   * This call causes the authentication window to be closed.\r\n   * @param result Specifies a result for the authentication. If specified, the frame that initiated the authentication pop-up receives this value in its callback.\r\n   * @param callbackUrl Specifies the url to redirect back to if the client is Win32 Outlook.\r\n   */\r\n  export function notifyFailure(reason?: string, callbackUrl?: string): void {\r\n    redirectIfWin32Outlook(callbackUrl, \"reason\", reason);\r\n\r\n    ensureInitialized(frameContexts.authentication);\r\n\r\n    sendMessageRequest(parentWindow, \"authentication.authenticate.failure\", [\r\n      reason\r\n    ]);\r\n\r\n    // Wait for the message to be sent before closing the window\r\n    waitForMessageQueue(parentWindow, () =>\r\n      setTimeout(() => currentWindow.close(), 200)\r\n    );\r\n  }\r\n\r\n  function handleSuccess(result?: string): void {\r\n    try {\r\n      if (authParams && authParams.successCallback) {\r\n        authParams.successCallback(result);\r\n      }\r\n    } finally {\r\n      authParams = null;\r\n      closeAuthenticationWindow();\r\n    }\r\n  }\r\n\r\n  function handleFailure(reason?: string): void {\r\n    try {\r\n      if (authParams && authParams.failureCallback) {\r\n        authParams.failureCallback(reason);\r\n      }\r\n    } finally {\r\n      authParams = null;\r\n      closeAuthenticationWindow();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates that the callbackUrl param is a valid connector url, appends the result/reason and authSuccess/authFailure as URL fragments and redirects the window\r\n   * @param callbackUrl - the connectors url to redirect to\r\n   * @param key - \"result\" in case of success and \"reason\" in case of failure\r\n   * @param value - the value of the passed result/reason parameter\r\n   */\r\n  function redirectIfWin32Outlook(\r\n    callbackUrl?: string,\r\n    key?: string,\r\n    value?: string\r\n  ): void {\r\n    if (callbackUrl) {\r\n      const link = document.createElement(\"a\");\r\n      link.href = decodeURIComponent(callbackUrl);\r\n      if (\r\n        link.host &&\r\n        link.host !== window.location.host &&\r\n        link.host === \"outlook.office.com\" &&\r\n        link.search.indexOf(\"client_type=Win32_Outlook\") > -1\r\n      ) {\r\n        if (key && key === \"result\") {\r\n          if (value) {\r\n            link.href = updateUrlParameter(link.href, \"result\", value);\r\n          }\r\n          currentWindow.location.assign(\r\n            updateUrlParameter(link.href, \"authSuccess\", \"\")\r\n          );\r\n        }\r\n        if (key && key === \"reason\") {\r\n          if (value) {\r\n            link.href = updateUrlParameter(link.href, \"reason\", value);\r\n          }\r\n          currentWindow.location.assign(\r\n            updateUrlParameter(link.href, \"authFailure\", \"\")\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Appends either result or reason as a fragment to the 'callbackUrl'\r\n   * @param uri - the url to modify\r\n   * @param key - the fragment key\r\n   * @param value - the fragment value\r\n   */\r\n  function updateUrlParameter(uri: string, key: string, value: string): string {\r\n    const i = uri.indexOf(\"#\");\r\n    let hash = i === -1 ? \"#\" : uri.substr(i);\r\n    hash = hash + \"&\" + key + (value !== \"\" ? \"=\" + value : \"\");\r\n    uri = i === -1 ? uri : uri.substr(0, i);\r\n    return uri + hash;\r\n  }\r\n\r\n  export interface AuthenticateParameters {\r\n    /**\r\n     * The URL for the authentication pop-up.\r\n     */\r\n    url: string;\r\n\r\n    /**\r\n     * The preferred width for the pop-up. This value can be ignored if outside the acceptable bounds.\r\n     */\r\n    width?: number;\r\n\r\n    /**\r\n     * The preferred height for the pop-up. This value can be ignored if outside the acceptable bounds.\r\n     */\r\n    height?: number;\r\n\r\n    /**\r\n     * A function that is called if the authentication succeeds, with the result returned from the authentication pop-up.\r\n     */\r\n    successCallback?: (result?: string) => void;\r\n\r\n    /**\r\n     * A function that is called if the authentication fails, with the reason for the failure returned from the authentication pop-up.\r\n     */\r\n    failureCallback?: (reason?: string) => void;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Hide from docs.\r\n   * ------\r\n   */\r\n  export interface AuthTokenRequest {\r\n    /**\r\n     * An array of resource URIs identifying the target resources for which the token should be requested.\r\n     */\r\n    resources: string[];\r\n\r\n    /**\r\n     * A function that is called if the token request succeeds, with the resulting token.\r\n     */\r\n    successCallback?: (token: string) => void;\r\n\r\n    /**\r\n     * A function that is called if the token request fails, with the reason for the failure.\r\n     */\r\n    failureCallback?: (reason: string) => void;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Hide from docs.\r\n   * ------\r\n   */\r\n  export interface UserRequest {\r\n    /**\r\n     * A function that is called if the token request succeeds, with the resulting token.\r\n     */\r\n    successCallback?: (user: UserProfile) => void;\r\n\r\n    /**\r\n     * A function that is called if the token request fails, with the reason for the failure.\r\n     */\r\n    failureCallback?: (reason: string) => void;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * Hide from docs.\r\n   * ------\r\n   */\r\n  export interface UserProfile {\r\n    /**\r\n     * The intended recipient of the token. The application that receives the token must verify that the audience\r\n     * value is correct and reject any tokens intended for a different audience.\r\n     */\r\n    aud: string;\r\n\r\n    /**\r\n     * Identifies how the subject of the token was authenticated.\r\n     */\r\n    amr: string[];\r\n\r\n    /**\r\n     * Stores the time at which the token was issued. It is often used to measure token freshness.\r\n     */\r\n    iat: number;\r\n\r\n    /**\r\n     * Identifies the security token service (STS) that constructs and returns the token. In the tokens that Azure AD\r\n     * returns, the issuer is sts.windows.net. The GUID in the issuer claim value is the tenant ID of the Azure AD\r\n     * directory. The tenant ID is an immutable and reliable identifier of the directory.\r\n     */\r\n    iss: string;\r\n\r\n    /**\r\n     * Provides the last name, surname, or family name of the user as defined in the Azure AD user object.\r\n     */\r\n    family_name: string;\r\n\r\n    /**\r\n     * Provides the first or \"given\" name of the user, as set on the Azure AD user object.\r\n     */\r\n    given_name: string;\r\n\r\n    /**\r\n     * Provides a human-readable value that identifies the subject of the token. This value is not guaranteed to\r\n     * be unique within a tenant and is designed to be used only for display purposes.\r\n     */\r\n    unique_name: string;\r\n\r\n    /**\r\n     * Contains a unique identifier of an object in Azure AD. This value is immutable and cannot be reassigned or\r\n     * reused. Use the object ID to identify an object in queries to Azure AD.\r\n     */\r\n    oid: string;\r\n\r\n    /**\r\n     * Identifies the principal about which the token asserts information, such as the user of an application.\r\n     * This value is immutable and cannot be reassigned or reused, so it can be used to perform authorization\r\n     * checks safely. Because the subject is always present in the tokens the Azure AD issues, we recommended\r\n     * using this value in a general-purpose authorization system.\r\n     */\r\n    sub: string;\r\n\r\n    /**\r\n     * An immutable, non-reusable identifier that identifies the directory tenant that issued the token. You can\r\n     * use this value to access tenant-specific directory resources in a multitenant application. For example,\r\n     * you can use this value to identify the tenant in a call to the Graph API.\r\n     */\r\n    tid: string;\r\n\r\n    /**\r\n     * Defines the time interval within which a token is valid. The service that validates the token should verify\r\n     * that the current date is within the token lifetime; otherwise it should reject the token. The service might\r\n     * allow for up to five minutes beyond the token lifetime to account for any differences in clock time (\"time\r\n     * skew\") between Azure AD and the service.\r\n     */\r\n    exp: number;\r\n    nbf: number;\r\n\r\n    /**\r\n     * Stores the user name of the user principal.\r\n     */\r\n    upn: string;\r\n\r\n    /**\r\n     * Stores the version number of the token.\r\n     */\r\n    ver: string;\r\n  }\r\n}\r\n\r\nexport interface Context {\r\n  /**\r\n   * The Office 365 group ID for the team with which the content is associated.\r\n   * This field is available only when the identity permission is requested in the manifest.\r\n   */\r\n  groupId?: string;\r\n\r\n  /**\r\n   * The Microsoft Teams ID for the team with which the content is associated.\r\n   */\r\n  teamId?: string;\r\n\r\n  /**\r\n   * The name for the team with which the content is associated.\r\n   */\r\n  teamName?: string;\r\n\r\n  /**\r\n   * The Microsoft Teams ID for the channel with which the content is associated.\r\n   */\r\n  channelId?: string;\r\n\r\n  /**\r\n   * The name for the channel with which the content is associated.\r\n   */\r\n  channelName?: string;\r\n\r\n  /**\r\n   * The developer-defined unique ID for the entity this content points to.\r\n   */\r\n  entityId: string;\r\n\r\n  /**\r\n   * The developer-defined unique ID for the sub-entity this content points to.\r\n   * This field should be used to restore to a specific state within an entity, such as scrolling to or activating a specific piece of content.\r\n   */\r\n  subEntityId?: string;\r\n\r\n  /**\r\n   * The current locale that the user has configured for the app formatted as\r\n   * languageId-countryId (for example, en-us).\r\n   */\r\n  locale: string;\r\n\r\n  /**\r\n   * @deprecated Use loginHint or userPrincipalName.\r\n   * The UPN of the current user.\r\n   * Because a malicious party can run your content in a browser, this value should\r\n   * be used only as a hint as to who the user is and never as proof of identity.\r\n   * This field is available only when the identity permission is requested in the manifest.\r\n   */\r\n  upn?: string;\r\n\r\n  /**\r\n   * The Azure AD tenant ID of the current user.\r\n   * Because a malicious party can run your content in a browser, this value should\r\n   * be used only as a hint as to who the user is and never as proof of identity.\r\n   * This field is available only when the identity permission is requested in the manifest.\r\n   */\r\n  tid?: string;\r\n\r\n  /**\r\n   * The current UI theme.\r\n   */\r\n  theme?: string;\r\n\r\n  /**\r\n   * Indication whether the tab is in full-screen mode.\r\n   */\r\n  isFullScreen?: boolean;\r\n\r\n  /**\r\n   * The type of the team.\r\n   */\r\n  teamType?: TeamType;\r\n\r\n  /**\r\n   * The root SharePoint folder associated with the team.\r\n   */\r\n  teamSiteUrl?: string;\r\n\r\n  /**\r\n   * The relative path to the SharePoint folder associated with the channel.\r\n   */\r\n  channelRelativeUrl?: string;\r\n\r\n  /**\r\n   * Unique ID for the current Teams session for use in correlating telemetry data.\r\n   */\r\n  sessionId?: string;\r\n\r\n  /**\r\n   * The user's role in the team.\r\n   * Because a malicious party can run your content in a browser, this value should\r\n   * be used only as a hint as to the user's role, and never as proof of her role.\r\n   */\r\n  userTeamRole?: UserTeamRole;\r\n\r\n  /**\r\n   * The Microsoft Teams ID for the chat with which the content is associated.\r\n   */\r\n  chatId?: string;\r\n\r\n  /**\r\n   * A value suitable for use as a login_hint when authenticating with Azure AD.\r\n   * Because a malicious party can run your content in a browser, this value should\r\n   * be used only as a hint as to who the user is and never as proof of identity.\r\n   * This field is available only when the identity permission is requested in the manifest.\r\n   */\r\n  loginHint?: string;\r\n\r\n  /**\r\n   * The UPN of the current user. This may be an externally-authenticated UPN (e.g., guest users).\r\n   * Because a malicious party run your content in a browser, this value should\r\n   * be used only as a hint as to who the user is and never as proof of identity.\r\n   * This field is available only when the identity permission is requested in the manifest.\r\n   */\r\n  userPrincipalName?: string;\r\n\r\n  /**\r\n   * The Azure AD object id of the current user.\r\n   * Because a malicious party run your content in a browser, this value should\r\n   * be used only as a hint as to who the user is and never as proof of identity.\r\n   * This field is available only when the identity permission is requested in the manifest.\r\n   */\r\n  userObjectId?: string;\r\n\r\n  /**\r\n   * Indicates whether team is archived.\r\n   * Apps should use this as a signal to prevent any changes to content associated with archived teams.\r\n   */\r\n  isTeamArchived?: boolean;\r\n\r\n  /**\r\n   * The type of the host client. Possible values are : android, ios, web, desktop\r\n   */\r\n  hostClientType?: HostClientType;\r\n\r\n  /**\r\n   * SharePoint context\r\n   */\r\n  sharepoint?: any;\r\n\r\n  /**\r\n   * The type of license for the current users tenant.\r\n   */\r\n  tenantSKU?: string;\r\n\r\n  /**\r\n   * The license type for the current user.\r\n   */\r\n  userLicenseType?: string;\r\n}\r\n\r\nexport interface DeepLinkParameters {\r\n  /**\r\n   * The developer-defined unique ID for the sub-entity to which this deep link points in the current entity.\r\n   * This field should be used to restore to a specific state within an entity, such as scrolling to or activating a specific piece of content.\r\n   */\r\n  subEntityId: string;\r\n\r\n  /**\r\n   * The label for the sub-entity that should be displayed when the deep link is rendered in a client.\r\n   */\r\n  subEntityLabel: string;\r\n\r\n  /**\r\n   * The fallback URL to which to navigate the user if the client cannot render the page.\r\n   * This URL should lead directly to the sub-entity.\r\n   */\r\n  subEntityWebUrl?: string;\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs.\r\n * ------\r\n */\r\nexport interface FilePreviewParameters {\r\n  /**\r\n   * The developer-defined unique ID for the file.\r\n   */\r\n  entityId: string;\r\n\r\n  /**\r\n   * The display name of the file.\r\n   */\r\n  title: string;\r\n\r\n  /**\r\n   * An optional description of the file.\r\n   */\r\n  description?: string;\r\n\r\n  /**\r\n   * The file extension; e.g. pptx, docx, etc.\r\n   */\r\n  type: string;\r\n\r\n  /**\r\n   * A url to the source of the file, used to open the content in the user's default browser\r\n   */\r\n  objectUrl: string;\r\n\r\n  /**\r\n   * Optional; an alternate self-authenticating url used to preview the file in Mobile clients and offer it for download by the user\r\n   */\r\n  downloadUrl?: string;\r\n\r\n  /**\r\n   * Optional; an alternate url optimized for previewing the file in Teams web and desktop clients\r\n   */\r\n  webPreviewUrl?: string;\r\n\r\n  /**\r\n   * Optional; an alternate url that allows editing of the file in Teams web and desktop clients\r\n   */\r\n  webEditUrl?: string;\r\n\r\n  /**\r\n   * Optional; the base url of the site where the file is hosted\r\n   */\r\n  baseUrl?: string;\r\n\r\n  /**\r\n   * Optional; indicates whether the file should be opened in edit mode\r\n   */\r\n  editFile?: boolean;\r\n\r\n  /**\r\n   * Optional; the developer-defined unique ID for the sub-entity to return to when the file stage closes.\r\n   * This field should be used to restore to a specific state within an entity, such as scrolling to or activating a specific piece of content.\r\n   */\r\n  subEntityId?: string;\r\n}\r\n\r\nfunction ensureInitialized(...expectedFrameContexts: string[]): void {\r\n  if (!initializeCalled) {\r\n    throw new Error(\"The library has not yet been initialized\");\r\n  }\r\n\r\n  if (\r\n    frameContext &&\r\n    expectedFrameContexts &&\r\n    expectedFrameContexts.length > 0\r\n  ) {\r\n    let found = false;\r\n    for (let i = 0; i < expectedFrameContexts.length; i++) {\r\n      if (expectedFrameContexts[i] === frameContext) {\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!found) {\r\n      throw new Error(\r\n        \"This call is not allowed in the '\" + frameContext + \"' context\"\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction processMessage(evt: MessageEvent): void {\r\n  // Process only if we received a valid message\r\n  if (!evt || !evt.data || typeof evt.data !== \"object\") {\r\n    return;\r\n  }\r\n\r\n  // Process only if the message is coming from a different window and a valid origin\r\n  const messageSource = evt.source || evt.originalEvent.source;\r\n  const messageOrigin = evt.origin || evt.originalEvent.origin;\r\n  if (\r\n    messageSource === currentWindow ||\r\n    (messageOrigin !== currentWindow.location.origin &&\r\n      !validOriginRegExp.test(messageOrigin.toLowerCase()))\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  // Update our parent and child relationships based on this message\r\n  updateRelationships(messageSource, messageOrigin);\r\n\r\n  // Handle the message\r\n  if (messageSource === parentWindow) {\r\n    handleParentMessage(evt);\r\n  } else if (messageSource === childWindow) {\r\n    handleChildMessage(evt);\r\n  }\r\n}\r\n\r\nfunction updateRelationships(\r\n  messageSource: Window,\r\n  messageOrigin: string\r\n): void {\r\n  // Determine whether the source of the message is our parent or child and update our\r\n  // window and origin pointer accordingly\r\n  if (!parentWindow || messageSource === parentWindow) {\r\n    parentWindow = messageSource;\r\n    parentOrigin = messageOrigin;\r\n  } else if (!childWindow || messageSource === childWindow) {\r\n    childWindow = messageSource;\r\n    childOrigin = messageOrigin;\r\n  }\r\n\r\n  // Clean up pointers to closed parent and child windows\r\n  if (parentWindow && parentWindow.closed) {\r\n    parentWindow = null;\r\n    parentOrigin = null;\r\n  }\r\n  if (childWindow && childWindow.closed) {\r\n    childWindow = null;\r\n    childOrigin = null;\r\n  }\r\n\r\n  // If we have any messages in our queue, send them now\r\n  flushMessageQueue(parentWindow);\r\n  flushMessageQueue(childWindow);\r\n}\r\n\r\nfunction handleParentMessage(evt: MessageEvent): void {\r\n  if (\"id\" in evt.data) {\r\n    // Call any associated callbacks\r\n    const message = evt.data as MessageResponse;\r\n    const callback = callbacks[message.id];\r\n    if (callback) {\r\n      callback.apply(null, message.args);\r\n\r\n      // Remove the callback to ensure that the callback is called only once and to free up memory.\r\n      delete callbacks[message.id];\r\n    }\r\n  } else if (\"func\" in evt.data) {\r\n    // Delegate the request to the proper handler\r\n    const message = evt.data as MessageRequest;\r\n    const handler = handlers[message.func];\r\n    if (handler) {\r\n      // We don't expect any handler to respond at this point\r\n      handler.apply(this, message.args);\r\n    }\r\n  }\r\n}\r\n\r\nfunction handleChildMessage(evt: MessageEvent): void {\r\n  if (\"id\" in evt.data && \"func\" in evt.data) {\r\n    // Try to delegate the request to the proper handler\r\n    const message = evt.data as MessageRequest;\r\n    const handler = handlers[message.func];\r\n    if (handler) {\r\n      const result = handler.apply(this, message.args);\r\n      if (result) {\r\n        sendMessageResponse(\r\n          childWindow,\r\n          message.id,\r\n          Array.isArray(result) ? result : [result]\r\n        );\r\n      }\r\n    } else {\r\n      // Proxy to parent\r\n      const messageId = sendMessageRequest(\r\n        parentWindow,\r\n        message.func,\r\n        message.args\r\n      );\r\n\r\n      // tslint:disable-next-line:no-any\r\n      callbacks[messageId] = (...args: any[]) => {\r\n        if (childWindow) {\r\n          sendMessageResponse(childWindow, message.id, args);\r\n        }\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nfunction getTargetMessageQueue(targetWindow: Window): MessageRequest[] {\r\n  return targetWindow === parentWindow\r\n    ? parentMessageQueue\r\n    : targetWindow === childWindow\r\n      ? childMessageQueue\r\n      : [];\r\n}\r\n\r\nfunction getTargetOrigin(targetWindow: Window): string {\r\n  return targetWindow === parentWindow\r\n    ? parentOrigin\r\n    : targetWindow === childWindow\r\n      ? childOrigin\r\n      : null;\r\n}\r\n\r\nfunction flushMessageQueue(targetWindow: Window | any): void {\r\n  const targetOrigin = getTargetOrigin(targetWindow);\r\n  const targetMessageQueue = getTargetMessageQueue(targetWindow);\r\n  while (targetWindow && targetOrigin && targetMessageQueue.length > 0) {\r\n    targetWindow.postMessage(targetMessageQueue.shift(), targetOrigin);\r\n  }\r\n}\r\n\r\nfunction waitForMessageQueue(targetWindow: Window, callback: () => void): void {\r\n  const messageQueueMonitor = currentWindow.setInterval(() => {\r\n    if (getTargetMessageQueue(targetWindow).length === 0) {\r\n      clearInterval(messageQueueMonitor);\r\n      callback();\r\n    }\r\n  }, 100);\r\n}\r\n\r\nfunction sendMessageRequest(\r\n  targetWindow: Window | any,\r\n  actionName: string,\r\n  // tslint:disable-next-line: no-any\r\n  args?: any[]\r\n): number {\r\n  const request = createMessageRequest(actionName, args);\r\n  if (isFramelessWindow) {\r\n    if (currentWindow && currentWindow.nativeInterface) {\r\n      (currentWindow as ExtendedWindow).nativeInterface.framelessPostMessage(\r\n        JSON.stringify(request)\r\n      );\r\n    }\r\n  } else {\r\n    const targetOrigin = getTargetOrigin(targetWindow);\r\n\r\n    // If the target window isn't closed and we already know its origin, send the message right away; otherwise,\r\n    // queue the message and send it after the origin is established\r\n    if (targetWindow && targetOrigin) {\r\n      targetWindow.postMessage(request, targetOrigin);\r\n    } else {\r\n      getTargetMessageQueue(targetWindow).push(request);\r\n    }\r\n  }\r\n  return request.id;\r\n}\r\n\r\n/**\r\n * @private\r\n * Internal use only\r\n * Sends a custom action message to Teams.\r\n * @param actionName Specifies name of the custom action to be sent\r\n * @param args Specifies additional arguments passed to the action\r\n * @returns id of sent message\r\n */\r\nexport function sendCustomMessage(\r\n  actionName: string,\r\n  // tslint:disable-next-line:no-any\r\n  args?: any[]\r\n): number {\r\n  ensureInitialized();\r\n  return sendMessageRequest(parentWindow, actionName, args);\r\n}\r\n\r\nfunction sendMessageResponse(\r\n  targetWindow: Window | any,\r\n  id: number,\r\n  // tslint:disable-next-line:no-any\r\n  args?: any[]\r\n): void {\r\n  const response = createMessageResponse(id, args);\r\n  const targetOrigin = getTargetOrigin(targetWindow);\r\n  if (targetWindow && targetOrigin) {\r\n    targetWindow.postMessage(response, targetOrigin);\r\n  }\r\n}\r\n\r\n// tslint:disable-next-line:no-any\r\nfunction createMessageRequest(func: string, args: any[]): MessageRequest {\r\n  return {\r\n    id: nextMessageId++,\r\n    func: func,\r\n    args: args || []\r\n  };\r\n}\r\n\r\n// tslint:disable-next-line:no-any\r\nfunction createMessageResponse(id: number, args: any[]): MessageResponse {\r\n  return {\r\n    id: id,\r\n    args: args || []\r\n  };\r\n}\r\n\r\nexport interface TaskInfo {\r\n  /**\r\n   * The url to be rendered in the webview/iframe.\r\n   */\r\n  url?: string;\r\n\r\n  /**\r\n   * JSON defining an adaptive card.\r\n   */\r\n  card?: string;\r\n\r\n  /**\r\n   * The requested height of the webview/iframe.\r\n   */\r\n  height?: TaskModuleDimension | Number;\r\n\r\n  /**\r\n   * The requested width of the webview/iframe.\r\n   */\r\n  width?: TaskModuleDimension | Number;\r\n\r\n  /**\r\n   * Title of the task module.\r\n   */\r\n  title?: string;\r\n\r\n  /**\r\n   * If client doesnt support the URL, the URL that needs to be opened in the browser.\r\n   */\r\n  fallbackUrl?: string;\r\n\r\n  /**\r\n   * Specifies a bot ID to send the result of the user's interaction with the task module.\r\n   * If specified, the bot will receive a task/complete invoke event with a JSON object\r\n   * in the event payload.\r\n   */\r\n  completionBotId?: string;\r\n}\r\n\r\n/**\r\n * Namespace to interact with the task module-specific part of the SDK.\r\n * This object is usable only on the content frame.\r\n */\r\nexport namespace tasks {\r\n  /**\r\n   * Allows an app to open the task module.\r\n   * @param taskInfo An object containing the parameters of the task module\r\n   * @param submitHandler Handler to call when the task module is completed\r\n   */\r\n  export function startTask(\r\n    taskInfo: TaskInfo,\r\n    submitHandler?: (err: string, result: string) => void\r\n  ): void {\r\n    ensureInitialized(frameContexts.content);\r\n\r\n    const messageId = sendMessageRequest(parentWindow, \"tasks.startTask\", [\r\n      taskInfo\r\n    ]);\r\n    callbacks[messageId] = submitHandler;\r\n  }\r\n\r\n  /**\r\n   * Update height/width task info properties.\r\n   * @param taskInfo An object containing width and height properties\r\n   */\r\n  export function updateTask(taskInfo: TaskInfo): void {\r\n    ensureInitialized(frameContexts.content, frameContexts.task);\r\n    const { width, height, ...extra } = taskInfo;\r\n\r\n    if (!Object.keys(extra).length) {\r\n      sendMessageRequest(parentWindow, \"tasks.updateTask\", [taskInfo]);\r\n    } else {\r\n      throw new Error(\r\n        \"updateTask requires a taskInfo argument containing only width and height\"\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Submit the task module.\r\n   * @param result Contains the result to be sent to the bot or the app. Typically a JSON object or a serialized version of it\r\n   * @param appIds Helps to validate that the call originates from the same appId as the one that invoked the task module\r\n   */\r\n  export function submitTask(\r\n    result?: string | object,\r\n    appIds?: string | string[]\r\n  ): void {\r\n    ensureInitialized(frameContexts.content, frameContexts.task);\r\n\r\n    // Send tasks.completeTask instead of tasks.submitTask message for backward compatibility with Mobile clients\r\n    sendMessageRequest(parentWindow, \"tasks.completeTask\", [\r\n      result,\r\n      Array.isArray(appIds) ? appIds : [appIds]\r\n    ]);\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs\r\n * --------\r\n * Information about all members in a chat\r\n */\r\nexport interface ChatMembersInformation {\r\n  members: ThreadMember[];\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs\r\n * --------\r\n * Information about a chat member\r\n */\r\nexport interface ThreadMember {\r\n  /**\r\n   * The member's user principal name in the current tenant.\r\n   */\r\n  upn: string;\r\n}\r\n\r\n/**\r\n * @private\r\n * Hide from docs\r\n * ------\r\n * Allows an app to retrieve information of all chat members\r\n * Because a malicious party run your content in a browser, this value should\r\n * be used only as a hint as to who the members are and never as proof of membership.\r\n * @param callback The callback to invoke when the {@link ChatMembersInformation} object is retrieved.\r\n */\r\nexport function getChatMembers(\r\n  callback: (chatMembersInformation: ChatMembersInformation) => void\r\n): void {\r\n  ensureInitialized();\r\n\r\n  const messageId = sendMessageRequest(parentWindow, \"getChatMembers\");\r\n  callbacks[messageId] = callback;\r\n}\r\n"],"sourceRoot":""}